<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Generator: Mesh generation module</title>
    <link href="Cassiopee.css" rel="stylesheet" type="text/css">
    <link rel="icon" type="image/png" href="iconc.png"> </link>
    <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-31301505-1', 'auto');ga('send', 'pageview');</script>
  </head>

  <body>
    <h1>Generator: Mesh Generation</h1>
    <h2>Version: 2.4 (29/03/2017)</h2>
    <h2>Author: Onera</h2>
    <h2><a href="Latex/Generator.pdf" target="_self"><img src="pdf_logo.gif" alt="Download pdf version."></a></h2>
  <HR>

    <h3>Preamble</h3>

    This module can be used to generate meshes from geometries.
    A mesh
    can be stored as an array (as defined in the Converter documentation)
    or in a zone node of a CGNS/python tree (pyTree).<br><br>

    This module is part of Cassiopee, a free open-source
    pre- and post-processor for CFD simulations.<br><br>

    When using the array interface, import the Generator module:
    <div class="code">
      import Generator as G
    </div>
    Then, a is an array and A is a list of arrays.<br>

    When using the pyTree interface, import the module:
    <div class="code">
      import Generator.PyTree as G
    </div>
    Then, a is a zone node and A is a list of zone nodes or a pyTree.<br>

    <p></p>
    <h3>Basic grid generation</h3>
    <p></p>

    <strong>G.cart</strong>: create a structured Cartesian mesh with ni x nj x nk
    points starting from point (xo,yo,zo) and of step (hi,hj,hk):
    <div class="code">
      a = G.cart((xo,yo,zo), (hi,hj,hk), (ni,nj,nk))
    </div>
    <em>Example of use: </em><a href="Examples/Generator/cart.py"> Cartesian mesh (array)</a>,
    <a href="Examples/Generator/cartPT.py"> Cartesian mesh (pyTree).</a><br><br>

    <strong>G.cartHexa</strong>: create an unstructured hexahedral mesh defined from a Cartesian grid of ni x nj x nk points
    starting from point (xo,yo,zo)
    and of step (hi,hj,hk). Type of elements are 'QUAD' for 2D arrays and 'HEXA' for 3D arrays:
    <div class="code">
     a = G.cartHexa((xo,yo,zo), (hi,hj,hk), (ni,nj,nk))
    </div>
    <em>Example of use: </em><a href="Examples/Generator/cartHexa.py"> hexahedral Cartesian mesh (array)</a>,
    <a href="Examples/Generator/cartHexaPT.py"> hexahedral Cartesian mesh (pyTree)</a>.<br><br>

    <strong>G.cartTetra</strong>: create an unstructured tetrahedral mesh defined from a Cartesian grid of ni x nj x nk points starting from point (xo,yo,zo)
    and of step (hi,hj,hk). Type of elements are 'TRI' for 2D arrays and 'TETRA' for 3D arrays:
    <div class="code">
     a = G.cartTetra((xo,yo,zo), (hi,hj,hk), (ni,nj,nk))
    </div>
    <em>Example of use: </em><a href="Examples/Generator/cartTetra.py"> tetrahedral Cartesian mesh (array)</a>,
    <a href="Examples/Generator/cartTetraPT.py"> tetrahedral Cartesian mesh (pyTree)</a>.<br><br>

    <strong>G.cartPenta</strong>: create an unstructured prismatic mesh defined from a regular Cartesian mesh.
    The initial Cartesian mesh is defined by ni x nj x nk points starting from point (xo,yo,zo)
    and of step (hi,hj,hk). Type of elements is 'PENTA':
    <div class="code">
     a = G.cartPenta((xo,yo,zo), (hi,hj,hk), (ni,nj,nk))
    </div>
    <em>Example of use: </em><a href="Examples/Generator/cartPenta.py"> prismatic mesh (array)</a>,
    <a href="Examples/Generator/cartPentaPT.py"> prismatic mesh (pyTree)</a>.<br><br>

    <strong>G.cartPyra</strong>: create an unstructured pyramidal mesh defined from a regular Cartesian mesh.
    The initial Cartesian mesh is defined by ni x nj x nk points starting from point (xo,yo,zo)
    and of step (hi,hj,hk). Type of elements is 'PYRA':
    <div class="code">
     a = G.cartPyra((xo,yo,zo), (hi,hj,hk), (ni,nj,nk))
    </div>
    <em>Example of use: </em><a href="Examples/Generator/cartPyra.py"> pyramidal mesh(array)</a>,
    <a href="Examples/Generator/cartPyraPT.py"> pyramidal mesh (pyTree)</a>.<br><br>

    <strong>G.cartNGon</strong>: create a NGON mesh defined from a regular Cartesian mesh.
    The initial Cartesian mesh is defined by ni x nj x nk points starting from point (xo,yo,zo)
    and of step (hi,hj,hk). Type of elements is 'NGON':
    <div class="code">
     a = G.cartNGon((xo,yo,zo), (hi,hj,hk), (ni,nj,nk))
    </div>
    <em>Example of use: </em><a href="Examples/Generator/cartNGon.py"> NGON Cartesian mesh(array)</a>,
    <a href="Examples/Generator/cartNGonPT.py"> NGON Cartesian mesh (pyTree)</a>.<br><br>

    <strong>G.cylinder</strong>: create a regular cylindrical grid (or a portion of cylinder between tetas and tetae)
    with ni x nj x nk points, of center-bottom point (xo,yo,zo), of
    inner radius R1, outer radius R2  and height H. For a direct mesh,
    use tetae < tetas:
    <div class="code">
      a = G.cylinder((xo,yo,zo), R1, R2, tetas, tetae, H, (ni,nj,nk))
    </div>
    <em>Example of use: </em><a href="Examples/Generator/cylinder.py"> regular cylindrical mesh (array)</a>,
    <a href="Examples/Generator/cylinderPT.py"> regular cylindrical mesh (pyTree)</a>.<br><br>

    <strong>G.cylinder2</strong>: create an irregular cylindrical grid (or a portion of cylinder between
    tetas and tetae) with ni x nj x nk points, of center-bottom point
    (xo,yo,zo), of inner radius R1, outer radius R2, height H and with distributions in
    r, teta, z. Distributions are arrays defining 1D meshes (x and i varying)
    giving a distribution in [0,1]. Their number of points gives ni, nj, nk:
    <div class="code">
      a = G.cylinder2((xo,yo,zo), R1, R2, tetas, tetae, H, arrayR, arrayTeta, arrayZ)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/cylinder2.py"> irregular cylindrical mesh (array)</a>,
    <a href="Examples/Generator/cylinder2PT.py"> irregular cylindrical mesh (pyTree)</a>.<br><br>

    <strong>G.cylinder3</strong>: create an irregular cylindrical grid (or a portion of cylinder between
    tetas and tetae) from a xz plane mesh defined by a and a
    teta distribution defined by arrayTeta:
    <div class="code">
      b = G.cylinder3(a, tetas, tetae, arrayTeta)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/cylinder3.py"> irregular cylindrical mesh (array)</a>,
    <a href="Examples/Generator/cylinder3PT.py"> irregular cylindrical mesh (pyTree)</a>.<br>

    <p></p>
    <h3>General purpose grid generators</h3>
    <p></p>

    <strong>G.delaunay</strong>: create a 2D Delaunay type mesh from an array. The array can be a 2D structured array, or an unstructured array of type 'NODE', 'TRI' or 'QUAD'.
    Tol is a geometric tolerance. Points nearer than tol are merged. If keepBB is set to 1, the bounding box is kept in the final triangulation:
    <div class="code">
    b = G.delaunay(a, tol=1.e-10, keepBB=0)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/delaunay.py"> Delaunay mesh from a 2D Cartesian grid (array)</a>,
    <a href="Examples/Generator/delaunayPT.py"> Delaunay mesh from a 2D Cartesian grid (pyTree)</a>.<br><br>

    <strong>G.constrainedDelaunay</strong>: create a constrained Delaunay triangulation of the convex hull of a contour c.
    Contour must be a BAR-array and must be in the plane (x,y).
    Tol is a geometric tolerance.
    Points nearer than tol are merged.
    If keepBB is set to 1, the bounding box is kept in the final triangulation:
    <div class="code">
       b = G.constrainedDelaunay(c, tol=1.e-10, keepBB=0)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/constrainedDelaunay.py"> constrained Delaunay mesh from a polyline (array)</a>,
    <a href="Examples/Generator/constrainedDelaunayPT.py"> constrained Delaunay mesh from a polyline (pyTree)</a>.<br><br>

    <strong>G.checkDelaunay</strong>: check if the Delaunay triangulation defined in tri is inside the contour c:
    <div class="code">
    c2 = G.checkDelaunay(c, tri)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/checkDelaunay.py"> check the Delaunay triangulation inside the contour(array)</a>,
    <a href="Examples/Generator/checkDelaunayPT.py"> check the Delaunay triangulation inside the contour(pyTree)</a>.<br><br>

    <strong>G.T3mesher2D</strong>: create a 2D Delaunay mesh given a BAR defined in a. If
    triangulateOnly=1 then only points of a are triangulated,
    if triangulateOnly=0, then interior points are inserted:
    <div class="code">
      b = G.T3mesher2D(a, triangulateOnly=0)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/T3mesher2D.py"> create a Delaunay mesh in a circle (array)</a>,
    <a href="Examples/Generator/T3mesher2DPT.py"> create a Delaunay mesh in a circle (pyTree)</a>.<br><br>

    <strong>G.TetraMesher</strong>: create a 3D tetra mesh given a TRI surface defined in a. If the TRI surface has external normals, tetras are filled inside
    the surface.
    If algo=0, netgen is used, if algo=1, tetgen is used:
    <div class="code">
      b = G.tetraMesher(a, algo=1)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/tetraMesher.py"> create a tetra mesh in a cube (array)</a>,
    <a href="Examples/Generator/tetraMesherPT.py"> create a tetra mesh in a cube (pyTree)</a>.<br><br>

    <strong>G.TFI</strong>: generate a mesh by transfinite interpolation (TFI). Generated mesh can be 2D or 3D structured, or unstructured TRI or PENTA mesh.
    Warning: the boundaries can be in a different order from the examples below, except for the PENTA TFI meshes.<br>
    2D structured mesh is built from imin, imax, jmin, jmax boundaries.<br>
    3D structured mesh is built from imin, imax, jmin, jmax, kmin, kmax boundaries.<br>
    Dimensions must be equal for each pair (imin,imax), (jmin,jmax)...<br>
    TRI mesh is built from imin, jmin, diag boundaries. Each boundary is a structured array with the same dimension.
    PENTA mesh is built from Tmin, Tmax triangles boundary and imin, imax, diag boundaries. Tmin, Tmax must be structured triangles of dimension nxn.
    imin, jmin, diag must be structured n*p arrays:
    <div class="code">
      2D-struct: a = G.TFI([imin, imax, jmin, jmax]) <br>
      3D-struct: a = G.TFI([imin, imax, jmin, jmax, kmin, kmax]) <br>
      TRI: a = G.TFI([imin, jmin, diag]) <br>
      PENTA: a = G.TFI([Tmin, Tmax, imin, imax, diag])
    </div>
    <em>Example of use: </em><a href="Examples/Generator/TFI.py"> TFI example (array)</a>,
    <a href="Examples/Generator/TFIPT.py"> TFI example (pyTree)</a>.<br><br>

    <strong>G.TFITri</strong>: generate three meshes by transfinite interpolation around three given curves a1, a2, a3. N3-N2+N1 must be odd:
    <div class="code">
    A = G.TFITri(a1, a2, a3)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/TFITri.py"> TFITri example (array)</a>,
    <a href="Examples/Generator/TFITriPT.py"> TFITri example (pyTree)</a>.<br><br>

    <strong>G.TFIO</strong>: generate five meshes by transfinite interpolation around one given curves a. The number of points of a must be odd:
    <div class="code">
    A = G.TFIO(a)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/TFIO.py"> TFIO example (array)</a>,
    <a href="Examples/Generator/TFIOPT.py"> TFIO example (pyTree)</a>.<br><br>

    <strong>G.TFIHalfO</strong>: generate four meshes by transfinite interpolation around two given curves a1 and a2 forming a half-O. N1 and N2 must be odd:
    <div class="code">
    A = G.TFIHalfO(a)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/TFIHalfO.py"> TFIHalfO example (array)</a>,
    <a href="Examples/Generator/TFIHalfOPT.py"> TFIHalfO example (pyTree)</a>.<br><br>

    <strong>G.TFIMono</strong>: generate one mesh by transfinite interpolation around two given curves a1 and a2 forming a half-O. N1-N2 must be even:
    <div class="code">
    A = G.TFIMono(a)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/TFIMono.py"> TFIMono example (array)</a>,
    <a href="Examples/Generator/TFIMonoPT.py"> TFIMono example (pyTree)</a>.<br><br>

    <strong>G.hyper2D</strong>: generate an hyperbolic mesh (2D) of "C" or "O" type from a from
    a line defined by line a and from a distribution defined by distrib.
    The resulting mesh is nearly orthogonal:
    <div class="code">
      b = G.hyper2D(line, distrib, "C")
    </div>
    <em>Example of use: </em><a href="Examples/Generator/hyper2d.py"> hyperbolic mesh generation (array)</a>,
    <a href="Examples/Generator/hyper2dPT.py"> hyperbolic mesh generation (pyTree)</a>.<br><br>

<!--     Generate an hyperbolic mesh (2D) of "C" or "O" type from a distribution  -->
<!--     array d. -->
<!--     The angle between mesh lines is set to alpha (in degrees): -->
<!--     <div class="code"> -->
<!--       b = G.hyper2D2(a, d, "C", alpha) -->
<!--     </div> -->
<!--     <em>Example of use: </em><a href="Examples/Generator/hyper2d2.py"> hyperbolic meh generation with angle between mesh lines.</a><br> -->

<!--     Generate an hyperbolic mesh (2D) of "C" or "O" type  -->
<!--     from a distribution array d. -->
<!--     Angles alpha1 and alpha2 corresponding to the line curvature at left and -->
<!--     right boundary are given (in degrees): -->
<!--     <div class="code"> -->
<!--       b = G.hyper2D3(a, d, "C", alpha1, alpha2) -->
<!--     </div> -->
<!--     <em>Example of use: </em><a href="Examples/Generator/hyper2d3.py"> hyperbolic meh generation with boundary angles.</a><br> -->

    <strong>G.PolyLine.polyLineMesher</strong>: generate a 2D mesh around a 2D polyline:
    <div class="code">
    B = G.PolyLine.polyLineMesher(a, h, hf, density)
    </div>
    where a is the input polyline (BAR-array), h is the height of the mesh,
    hf is the height of the first cell and density is the number of points
    per unity of length.<br>
    In the 'array' version, it returns a list where B[0] is the list
    of generated meshes, B[1] is the list of wall boundaries, B[2] is
    the list of overlap boundaries, B[3] is h, B[4] is density
    (eventually modified by the mesher).<br>
    In the pyTree version, it returns a list [zones,hs,densities], where zones is a list of zones of a CGNS python tree, containing the blocks,
    wall boundaries, match and overlap boundaries; hs is the list of heights (modified if necessary),
    and densities the list of densities (also modified if necessary). <br>
    <em>Example of use: </em><a href="Examples/Generator/polyLineMesher.py"> generates meshes around a polyline (array)</a>,
    <a href="Examples/Generator/polyLineMesherPT.py"> generates meshes around a polyline (pyTree)</a>.<br><br>

    <strong>G.PolyC1.polyC1Mesher</strong>: generate a 2D mesh around a 2D polyC1 curve:
    <div class="code">
    B = G.PolyC1.polyC1Mesher(A, h, hf, density, splitCrit=10.)
    </div>
    where A is a list of i-arrays each representing a
    C1 curve. All i-arrays put together must represent a polyC1 curve.
    SplitCrit is a curvature radius triggering split.
    Other arguments are similar to polyLineMesher. The function return
    is also similar to polyLineMesher. <br>
    <em>Example of use: </em><a href="Examples/Generator/polyC1Mesher.py"> generates meshes around a polyC1 curve (array)</a>,
    <a href="Examples/Generator/polyC1MesherPT.py"> generates meshes around a polyC1 curve (pyTree)</a>.<br><br>

    <strong>G.pointedHat</strong>: create a structured mesh from a curve defined by a i-array and a point. For the pyTree version: if a contains a solution, it is not taken into
    account in b:
    <div class="code">
    b = G.pointedHat(a, (x,y,z))
    </div>
    <em>Example of use: </em><a href="Examples/Generator/pointedHat.py"> pointed hat (array)</a>,
    <a href="Examples/Generator/pointedHatPT.py"> pointed hat (pyTree)</a>.<br><br>

    <strong>G.stitchedHat</strong>: create a stitched mesh from a curve defined by a i-array. The surface
    is stitched in the middle. Tol is the accuracy of the search, tol2 is
    a merging tolerance and offx, offy, off z an optional offset.
    For the pyTree version: if a contains a solution, it is not taken into account in b:
    <div class="code">
    b = G.stitchedHat(a, (offx,offy,offz), tol=1.e-6, tol2=1.e-5)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/stitchedHat.py"> stitched hat (array)</a>.<br><br>

    <strong>G.surfaceWalk</strong>: surface extrusion starting from a curve,
    resulting into a surface mesh.
    dj is the distribution of points in the extrusion direction starting from c,
    niter the number of smoothing iterations.
    check=1 means that the extrusion stops at the layer before cells intersect
    alphaRef is the deviation angle wrt 180 degrees enabling to stop the extrusion before it crosses a sharp edge on the surface.
    toldist is a tolerance below which points are considered matching.
    Constraints can be set as 1D zones:
    <div class="code">
    walk = G.surfaceWalk(surfaces, c, dj, constraints=[], niter=0, alphaRef=180., check=0, toldist=1.e-6)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/surfaceWalk.py"> surface walk (array)</a>,
    <a href="Examples/Generator/surfaceWalkPT.py"> surface walk (pyTree)</a>.<br><br>

    <strong>G.collarMesh*</strong>: create a collar mesh at junction(s) between two surfaces s1 and s2 in
    union or difference assembly, using a distribution along the surface dj
    and a distribution in the normal direction to the wall dk. niterj and
    niterk are the number of smoothing iterations for j and k directions.
    ext is the extension of the collar mesh for difference assembly.
    type is the assembly type, and can be 'union' or 'difference'.
    alphaRef is the deviation angle wrt 180 degrees above which the walk is stopped.
    contour is the starting contour to create the collar grids, constraints1 and constraints2 are 1D zones
    defining the curves the collar grid must follow on surfaces s1 and s2 respectively.
    toldist is the matching point tolerance. Parameter 'topology' can be 'overset' or 'extruded', only useful in case of difference.
    Topology set to 'overset' results in two overlapping collar grids, whereas it results in a collar grid extruded from the
    surface grid in the other case:
    <div class="code">
    A = G.collarMesh(s1, s2, dj,dk, niterj=100, niterk=100, ext=5, alphaRef=30., type='union', contour=[], constraints1=[], constraints2=[], toldist=1.e-10, topology='overset')
    </div>
    <em>Example of use: </em><a href="Examples/Generator/collarMesh.py"> collar mesh generation (array)</a>,
    <a href="Examples/Generator/collarMeshPT.py"> collar mesh generation (pyTree)</a>.<br><br>

    <p></p>
    <h3>Cartesian grid generators</h3>
    <p></p>
    <strong>G.gencartmb</strong>: simple Cartesian generator.
    Create a set of Cartesian grids (B) around a list of body grids (A).
    Those grids are patched with a ratio of 2. The user controls the number of levels, and the number of points for each level of grid.
    h is the spatial step on the finest level.
    Dfar is the maximal distance to the body.
    nlvl is a list that provides the number of points per level (nlvl[0]: finest grid), except for the finest level:
    <div class="code">
    B = G.gencartmb(A, h, Dfar, nlvl)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/gencartmb.py"> multiblock Cartesian grid set (array)</a>,
    <a href="Examples/Generator/gencartmbPT.py"> multiblock Cartesian grid set (pyTree)</a>.<br><br>

    <strong>G.octree</strong>: create a QUAD quadtree mesh in 2D or an HEXA octree mesh in 3D starting
    from a list of bodies and snears. Each parameter snear is the required spatial
    step of the octree near the corresponding body; dfar is the extension
    of the octree mesh in all the directions; balancing=1 means that the octree
    is balanced, i.e. adjacent elements are at worst twice as big/small;
    levelMax is the maximum number of levels required.
    If ratio=2, then a classical octree mesh is built. If ratio=3, a 27-tree mesh is built,
    in which case the spacing ratio is 3 (and not 2) between two adjacent elements:
    <div class="code">
    b = G.octree(surfs, snears, dfar=5., balancing=0, levelMax=1000, ratio=2)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/octree.py"> generates a quadtree starting from a circle (array)</a>,
    <a href="Examples/Generator/octreePT.py"> generates a quad tree starting from a circle (pyTree)</a>.<br><br>

    <strong>G.octree2Struct</strong>: convert an octree or a quadtree mesh into a set of Cartesian grids.
    Parameter ext is the extension of Cartesian grids in all the directions;
    vmin can be an integer defining the number of points in each Cartesian grid, or a list of integers, defining the
    number of points per refinement level. In that case, the first element of the list of vmin defines the
    finest level.  Specifying all the levels is not mandatory.
    If optimized=1, the ext value is reduced by -1 at overlap borders for the coarsest grid for minimum overlapping.
    If merged=1, Cartesian grids are merged in order to reduce the number of created grids.
    If AMR=1, a set of AMR zones are generated.
    Parameter sizeMax can be used when merging is applied: in that case, the number of points per grid does not exceed sizeMax.
    Warning: to obtain multigrid blocks, optimized must be set to 0:
    <div class="code">
    b = G.octree2Struct(octree, vmin=15, ext=0, optimized=1, merged=1, AMR=0, sizeMax=1000000)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/octree2Struct.py"> builds a Cartesian mesh from an octree (array)</a>,
    <a href="Examples/Generator/octree2StructPT.py"> builds a Cartesian mesh from an octree (pyTree)</a>.<br><br>

    <strong>G.adaptOctree</strong>: adapt an unstructured octree with respect
    to an indicator field located at element centers.
    If 'indicator' is strictly positive for an element, then the element
    must be refined as many times as required by the indicator number.
    If 'indicator' is strictly negative, the element is coarsened if
    possible as many times as required by the indicator number.
    If 'indicator' is 0., the element remains unchanged.
    balancing=1 means that the octree is balanced after adaptation.
    If ratio=2, then a classical octree mesh is built. If ratio=3, a 27-tree
    mesh is built, in which case the spacing ratio is 3 (and not 2) between
    two adjacent elements. For array interface indicator is an array,
    for pyTree version, indicator is the name of field
    stored as a solution located at centers:
    <div class="code">
    res = G.adaptOctree(octree, indicator, balancing=1, ratio=2)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/adaptOctree.py"> adapt an octree (array)</a>,
    </em><a href="Examples/Generator/adaptOctreePT.py"> adapt an octree (pyTree)</a>.<br><br>

    <strong>G.expandLayer</strong>:
    Expand the layer of given level for an octree unstructured mesh. If corners=1, expand also in corners directions:
    <div class="code">
    res = G.expandLayer(octree, level=0, corners=0, balancing=0)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/expandLayer.py"> expand the layer of finest level of an octree (array)</a>,
    <a href="Examples/Generator/expandLayerPT.py"> expand the layer of finest level of an octree (pyTree)</a>.<br><br>

<!--     Conformize an octree mesh with a ratio of 3 between adjacent levels: -->
<!--     <div class="code"> -->
<!--     b = G.conformOctree3(a) -->
<!--     </div> -->
<!--     <em>Example of use: </em><a href="Examples/Generator/conformOctree3.py"> conformize an octree3 (array)</a>, -->
<!--     <a href="Examples/Generator/conformOctree3PT.py"> conformize an octree3 (pyTree)</a>.<br> -->

    <p></p>
    <h3>Operations on meshes</h3>
    <p></p>

    <strong>G.close</strong>: close a mesh defined by array a. Points that are distant of tol maximum to one another are merged:
    <div class="code">
      b = G.close(a, tol=1.e-12) <em>.or.</em> B = G.close(A, tol=1.e-12)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/close.py"> mesh closing (array)</a>,
    <a href="Examples/Generator/closePT.py"> mesh closing (pyTree)</a>.<br><br>

    <strong>G.selectInsideElts</strong>: select elements of a TRI-array, whose centers are inside the given
    list of curves, defined by BAR-arrays:
    <div class="code">
     b = G.selectInsideElts(a, curves)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/selectInsideElts.py"> select inside elements (array)</a>.<br><br>

    <strong>G.map</strong>: map a distribution on a curve or on a structured surface:
    <div class="code">
      b = G.map(a, distrib)
    </div>
    Map a i-array distribution in a direction (dir=1,2,3) in a surface or volume mesh:
    <div class="code">
     b = G.map(a, distrib, dir)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/map.py"> distribution mapping (array)</a>,
    <a href="Examples/Generator/mapPT.py"> distribution mapping (pyTree)</a>.<br><br>

    <strong>G.mapSplit</strong>: split a i-array and map a distribution on the splitted i-array.
    SplitCrit is the curvature radius triggering split:
    <div class="code">
      b = G.mapSplit(a, distrib, splitCrit=100)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/mapSplit.py"> splitting and distribution mapping(array)</a>,
    <a href="Examples/Generator/mapSplitPT.py"> splitting and distribution mapping (pyTree)</a>.<br><br>

    <strong>G.refine</strong>: refine a structured array. The original distribution is kept
    but the number of points is multiplied by power. Dir is the direction
    of refinement (1, 2, 3). If dir=0, refine in all directions:
    <div class="code">
      b = G.refine(a, power, dir)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/refine.py"> refine an array (array)</a>,
    <a href="Examples/Generator/refinePT.py"> refine a pyTree (pyTree)</a>.<br><br>

    <strong>G.mapCurvature</strong>: map a structured array following the curvature. N is the final
    number of points. Dir is the direction
    of remeshing (1, 2, 3):
    <div class="code">
      b = G.mapCurvature(a, N, power, dir)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/mapCurvature.py"> map an array following curvature (array)</a>,
    <a href="Examples/Generator/mapCurvaturePT.py"> map a pyTree (pyTree)</a>.<br><br>

    <strong>G.densify</strong>: densify a i-array or a BAR-array with a new discretization step h.
    Discretization points from the original array are kept:
    <div class="code">
      b = G.densify(a, h)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/densify.py"> densify a 1D-array (array)</a>,
    <a href="Examples/Generator/densifyPT.py"> densify a 1D-pyTree (pyTree)</a>.<br><br>

    <strong>G.grow</strong>: grow a surface array of one layer. Vector is the node displacement.
    For the array version, vector is defined by an array. For the PyTree
    version, vector = ['v1','v2','v3'] where variables 'v1', 'v2', 'v3'
    are defined as solutions in a, located at nodes:
    <div class="code">
      b = G.grow(a, vector)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/grow.py"> grow a mesh of one layer (array)</a>,
    <a href="Examples/Generator/growPT.py"> grow a mesh of one layer (pyTree)</a>.<br><br>

    <strong>G.stack</strong>: stack two structured meshes (with the same nixnj) into a single mesh:
    <div class="code">
      c = G.stack(a, b)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/stack.py"> stack two layers (array)</a>,
    <a href="Examples/Generator/stackPT.py"> stack two layers (pyTree)</a>.<br><br>

    <strong>G.addNormalLayers</strong>: normal extrusion from a surface mesh. d is a 1D distribution providing the height of each layer.
    If check=1, the extrusion stops before negative volume cells are created. 
    Niter specifies the number of iterations for normals smoothing:
    <div class="code">
      b = G.addNormalLayers(a, d, check=0, niter=0)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/addNormalLayers.py"> add normal layers to a surface</a>,
    <a href="Examples/Generator/addNormalLayersPT.py"> normal extrusion (pyTree)</a>.<br><br>

    <strong>G.TTM</strong>: smooth a mesh using elliptic generator:
    <div class="code">
      b = G.TTM(a, niter=100)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/TTM.py"> TTM example (array)</a>,
    <a href="Examples/Generator/TTMPT.py"> TTM example (pyTree)</a>.<br><br>

    <strong>G.snapFront</strong>: snap a mesh to a surface S.
    A front must be defined in a by a cellN field.
    Points of this front are snapped to the surface. If optimized=0,
    the exterior front cellN=1 is snapped, else if optimized=1 optimized front cellN=1 is snapped, else if optimized=2, front cellN=0 is snapped:
    <div class="code">
      b = G.snapFront(a, S, optimized=1)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/snapFront.py"> snap front on a circular surface (array)</a>,
    <a href="Examples/Generator/snapFrontPT.py"> snap front on a circular surface (pyTree)</a>.<br><br>

    <strong>G.snapSharpEdges</strong>: snap a mesh to a surface S,
    constrained by sharp edges and corners. if step != None,
    sharp edges are refined with this step.
    Sharp Edges are calculated depending on angle:
    <div class="code">
      b = G.snapSharpEdges(a, S, step=None, angle=30.)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/snapSharpEdges.py"> snap a mesh on a polyline (array)</a>,
    <a href="Examples/Generator/snapSharpEdgesPT.py"> snap a mesh on a polyline (pyTree)</a>.<br><br>
    <p></p>
    <h3>Operations on surface meshes</h3>
    <p></p>
    <strong>G.fittingPlaster</strong>: fit a surface structured patch to a curve a. BumpFactor controls
    the curvature of the patch:
    <div class="code">
      b = G.fittingPlaster(a, bumpFactor=0.)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/fittingPlaster.py"> create a patch from a curve (array)</a>,
    <a href="Examples/Generator/fittingPlasterPT.py"> create a patch from a curve (pyTree)</a>.<br><br>

    <strong>G.gapfixer</strong>: fill a gap defined by a BAR contour a
    drawn on a surface c. You can force the generated mesh
    to pass through HardPoints (NODES). If refine=0, no inside
    points are added:
    <div class="code">
      b = G.gapfixer(a, c, hardPoints=None, refine=1)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/gapfixer.py"> fill the gap in a circle (array)</a>,
    <a href="Examples/Generator/gapfixerPT.py"> fix a gap in a circle (pyTree)</a>.<br><br>

    <strong>G.gapsmanager</strong>: fill multiple gaps in a set of surface components A. Also, eliminate
    overlap regions between components if any. Normals for all patches must be pointed outwards.
    Set mode=0 for nodal mesh, 1 for center mesh, and 2 otherwise.
    Set coplanar=1 if all components are lying on a same plane:
    <div class="code">
      B = G.gapsmanager(A, mode=0, coplanar=0)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/gapsmanager.py"> fill multiple gaps (array)</a>,
    <a href="Examples/Generator/gapsmanagerPT.py"> fill multiple gaps (pyTree)</a>.<br><br>

    <p></p>
    <h3>Information on generated meshes</h3>
    <p></p>
<!--     <p></p> -->
<!--     Check if a point P (x,y,z) is in the Cartesian Elements Bounding Box  -->
<!--     (CEBB) of mesh. Return 1 if true: -->
<!--     <div class="code"> -->
<!--       G.found = checkPointInCEBB(array, (x,y,z)) -->
<!--     </div> -->
<!--     <em>Example of use: </em><a href="Examples/Generator/checkPointInCEBB.py">check if point in CEBB of a mesh (array)</a>, -->
<!--          <a href="Examples/Generator/checkPointInCEBBPT.py">check if point in CEBB of a mesh (pyTree)</a>.<br> -->
<!--     <p></p> -->
<!--     Check if a boundary window (win) of a mesh defined by array2 intersects  -->
<!--     the Cartesian Elements Bounding Box (CEBB) of array1.  -->
<!--     Return 1 if true and 2 if besides,   -->
<!--     the mid-point of boundary is in the CEBB: -->
<!--     <div class="code"> -->
<!--       found = G.checkBoundaryInCEBB(array1, win, array2) -->
<!--     </div> -->
<!--     <em>Example of use: </em><a href="Examples/Generator/checkBoundaryInCEBB.py">Boundary window intersects Cartesian Element Bounding Box ?</a><br> -->

    <strong>G.check</strong>: check regularity, orthogonality for a mesh defined by an array:
    <div class="code">
    G.check(a)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/check.py"> mesh check (array)</a>,
    <a href="Examples/Generator/checkPT.py"> mesh check (pyTree)</a>.<br><br>

    <strong>G.barycenter</strong>: return the barycenter of a, with optional weight:
     <div class="code">
     bary = G.barycenter(a, weight=None) <em>.or.</em> bary = G.barycenter(A, weight=None)
     </div>
     <em> Example of use: </em> <a href="Examples/Generator/barycenter.py"> barycenter of array (array)</a>,
     <a href="Examples/Generator/barycenterPT.py"> barycenter of zone (pyTree)</a>.<br><br>

     <strong>G.bbox</strong>: return the bounding box [xmin, ymin, zmin, xmax, ymax, zmax] of a or A:
     <div class="code">
     bb = G.bbox(a) <em>.or.</em> bb = G.bbox(A)
     </div>
     <em> Example of use: </em> <a href="Examples/Generator/bbox.py"> bounding box (array)</a>,
     <a href="Examples/Generator/bboxPT.py"> bounding box (pyTree)</a>.<br><br>

     <strong>G.bboxOfCells</strong>: return the bounding box of each cell of a. The bounding box field is
     located at centers of cells:
     <div class="code">
     bb =  G.bboxOfCells(a) <em>.or.</em> BB = G.bboxOfCells(A)
     </div>
     <em> Example of use: </em> <a href="Examples/Generator/bboxOfCells.py"> bounding box of all cells (array)</a>,
     <a href="Examples/Generator/bboxOfCellsPT.py"> bounding box of all cells (pyTree)</a>.<br><br>

     <strong>G.BB</strong>: return the bounding box of a as an array or a zone. If method is 'AABB', then it computes
     the Axis-Aligned Bounding-Box, if method is 'OBB' then it computes the Oriented Bounding-Box. The argument
     weighting may be 0, and the OBB is computed using a Cloud-Point approach, or 1, and it is computed using a
     Surface-Weighting approach. If weighting=1, then the provided array must be a surface composed of triangles:
     <div class="code">
     b =  G.BB(a, method='AABB', weighting=0) <em>.or.</em> B = G.BB(A, method='AABB', weighting=0)
     </div>
     <em> Example of use: </em> <a href="Examples/Generator/BB.py"> bounding box of array (array)</a>,
     <a href="Examples/Generator/BBPT.py"> bounding box of zone (pyTree)</a>.<br><br>

     <strong>G.CEBBIntersection</strong>: test the Cartesian Elements Bounding Box (CEBB) intersection between a1
     and a2. Tolerance is a float given by tol. Return 0 if no intersection, 1 otherwise:
     <div class="code">
     intersect = G.CEBBIntersection(a1, a2, tol=1.e-10)
     </div>
     <em> Example of use: </em> <a href="Examples/Generator/CEBBIntersection.py"> CEBB intersection (array)</a>,
     <a href="Examples/Generator/CEBBIntersectionPT.py"> CEBB intersection (pyTree)</a>.<br><br>

     <strong>G.bboxIntersection</strong>: test if a1 and a2 intersects. Three options
     are available: method='AABB' (intersection between two Axis-Aligned Bounding Boxes, by default); method='OBB' (intersection between
     two Oriented Bounding Boxes, the most general case); method='AABBOBB' (intersection between an AABB -a1- and an OBB -a2-).;
     If a1 and a2 are directly the corresponding bounding boxes, the user may switch isBB=True in order to avoid recalculating them.
     Return 0 if no intersection, 1 otherwise:
     <div class="code">
     intersect = G.bboxIntersection(a1, a2, tol=1.e-6, isBB=False, method='AABB')
     </div>
     <em> Example of use: </em> <a href="Examples/Generator/bboxIntersection.py"> bounding box intersection (array)</a>,
     <a href="Examples/Generator/bboxIntersectionPT.py"> bounding box intersection (pyTree)</a>.<br><br>


     <strong>G.checkPointInCEBB</strong>: test if a given point is in the CEBB of a:
     <div class="code">
     inside = G.checkPointInCEBB(a, (x,y,z))
     </div>
     <em> Example of use: </em> <a href="Examples/Generator/checkPointInCEBB.py"> point in CEBB check (array)</a>,
     <a href="Examples/Generator/checkPointInCEBBPT.py"> Point in CEBB check (pyTree)</a>.<br><br>

    <strong>G.getVolumeMap</strong>: return the volume field of an array. Volume is located at centers of cells:
    <div class="code">
      b = G.getVolumeMap(a) <em>.or.</em> B = G.getVolumeMap(A)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/getVolumeMap.py"> volume field (array)</a>,
    <a href="Examples/Generator/getVolumeMapPT.py"> volume field (pyTree)</a>.<br><br>

     <strong>G.getNormalMap</strong>: return the surface normals field of a surface array. It is located at
    centers of cells:
    <div class="code">
      b = G.getNormalMap(a) <em>.or.</em> B = G.getNormalMap(A)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/getNormalMap.py"> surface normals field (array)</a>,
    <a href="Examples/Generator/getNormalMapPT.py"> surface normals field (pyTree)</a>. <br><br>

    <strong>G.getSmoothNormalMap</strong>: return the smoothed surface normals field of a surface array, located at nodes.
    niter is the number of smoothing operations, and eps is a smoothing weight  :
    <div class="code">
      b = G.getSmoothNormalMap(a, niter=2,eps=0.4) <em>.or.</em> B = G.getNormalMap(A, niter=2,eps=0.4)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/getSmoothNormalMap.py"> smoothed surface normals field (array)</a>,
    <a href="Examples/Generator/getSmoothNormalMapPT.py"> smoothed surface normals field (pyTree)</a>. <br><br>

    <strong>G.getOrthogonalityMap</strong>: return the orthogonality map of an array.
    The orthogonality map corresponds to the maximum deviation of
    all dihedral angles of an element.
    The orthogonality map is expressed in degree and located at centers:
    <div class="code">
      b = G.getOrthogonalityMap(a) <em>.or.</em> B = G.getOrthogonalityMap(A)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/getOrthogonalityMap.py"> orthogonality map (array)</a>,
    <a href="Examples/Generator/getOrthogonalityMapPT.py"> orthogonality map (pyTree)</a>.<br><br>

    <strong>G.getRegularityMap</strong>: return the regularity map of an array.
    The regularity map corresponds to the maximum deviation of the volume ratio
    of an element and all its neigbouring cells.
    The regularity map is located at centers:
    <div class="code">
      b = G.getRegularityMap(a) <em>.or.</em> B = G.getRegularityMap(A)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/getRegularityMap.py"> regularity map (array)</a>,
    <a href="Examples/Generator/getRegularityMapPT.py"> regularity map (pyTree)</a>.<br><br>

    <strong>G.getTriQualityMap</strong>: return the quality map of a TRI array.
    The triangle quality is a value between 0. (degenerated triangle) and 1. (equilateral triangle).
    The quality map is located at centers:
    <div class="code">
      b = G.getTriQualityMap(a) <em>.or.</em> B = G.getTriQualityMap(A)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/getTriQualityMap.py"> quality map of a TRI array (array)</a>,
    <a href="Examples/Generator/getTriQualityMapPT.py">  quality map of TRI zone (pyTree)</a>.<br><br>

    <strong>G.getCellPlanarity</strong>: return a measure of cell planarity for each cell. It is located at
    centers of cells:
    <div class="code">
      b = G.getCellPlanarity(a) <em>.or.</em> B = G.getCellPlanarity(A)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/getCellPlanarity.py"> cell planarity (array)</a>,
    <a href="Examples/Generator/getCellPlanarityPT.py"> cell planarity (pyTree)</a>.<br><br>

    <strong>G.getCircumCircleMap</strong>: return the map of circum circle radius of any cell of a 'TRI' array:
    <div class="code">
     b = G.getCircumCircleMap(a) <em>.or.</em> B = G.getCircumCircleMap(A)
     </div>
    <em>Example of use: </em><a href="Examples/Generator/getCircumCircleMap.py"> circum circle radius map (array)</a>,
    <a href="Examples/Generator/getCircumCircleMapPT.py"> circum circle radius map (pyTree)</a>.<br><br>

    <strong>G.getInCircleMap</strong>: return the map of inscribed circle radius of any cell of a 'TRI' array:
    <div class="code">
     b = G.getInCircleMap(a) <em>.or.</em> B = G.getInCircleMap(A)
     </div>
    <em>Example of use: </em><a href="Examples/Generator/getInCircleMap.py"> inscribed circle radius map (array)</a>,
    <a href="Examples/Generator/getInCircleMapPT.py"> inscribed circle radius map (pyTree)</a>.<br><br>

     <strong>G.getEdgeRatio</strong>: return the ratio between the longest and the smallest edges of a cell:
    <div class="code">
     r = G.getEdgeRatio(a) <em>.or.</em> B = G.getEdgeRatio(A)
     </div>
    <em>Example of use: </em><a href="Examples/Generator/getEdgeRatio.py"> ratio between edges of a mesh (array)</a>,
    <a href="Examples/Generator/getEdgeRatioPT.py"> ratio between edges of a mesh (pyTree)</a>.<br><br>

     <strong>G.getMaxEdgeLength</strong>: return the length of
     the longer edge of each cell:
    <div class="code">
     r = G.getMaxLength(a) <em>.or.</em> B = G.getMaxLength(A)
     </div>
    <em>Example of use: </em><a href="Examples/Generator/getMaxLength.py"> max length between edges of a mesh (array)</a>,
    <a href="Examples/Generator/getMaxLengthPT.py"> max length between edges of a mesh (pyTree)</a>.<br><br>

    <p></p>
    <h3>Operations on distributions</h3>
    <p></p>
    Distributions are Cartesian meshes that can be used to be
    mapped on profiles to make curvilinear meshes for instance.
    Distributions in 2D (x,y) distribution
    represent the length and height of each cell.
    Distributions in 3D (x,y,z) represents the lengths in the three topological
    directions of each cell. Distributions can be modified by the enforce
    functions.<br>
    The three following functions are also available in Y and Z directions: replace suffix 'X' by 'Y' or 'Z' in enforceX, enforcePlusX or enforceMoinsX functions.<br><br>

    <strong>G.enforceX</strong>: enforce a region around a line x=x0. The size of the cell around
    the line is enforcedh. "supp" points are suppressed from the starting
    distribution on the left and right side. "add" points are added on
    the left and add points are added on the right.
    Add exactely add points:
    <div class="code">
      b = G.enforceX(a, x0, enforcedh, (supp,add))
    </div>
    Adjust add in order to have a monotonic distribution:
    <div class="code">
     b = G.enforceX(a, x0, enforcedh, supp, add)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/enforceX.py"> point addition on both sides of line x (array)</a>,
    <a href="Examples/Generator/enforceXPT.py"> point addition in 2 sides of line x (pyTree)</a>.<br>
    <em>Example of use: </em><a href="Examples/Generator/enforce.py"> monotonic enforce (array)</a>,
    <a href="Examples/Generator/enforcePT.py"> monotonic enforce (pyTree)</a>.<br><br>

    <strong>G.enforceMoinsX</strong>: same as before but with a one sided distribution (left).
    This can be usefull to create a boundary layer distribution in an Euler mesh. <br>
    <div class="code">
    b = G.enforceMoinsX(a, enforcedh, (supp,add)) <em>.or.</em> b = G.enforceMoinsX(a, enforcedh, supp, add)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/enforceMoinsX.py"> point addition on the left side of line x (array)</a>,
    <a href="Examples/Generator/enforceMoinsXPT.py"> point addition on the left side of line x (pyTree)</a>.<br><br>

    <strong>G.enforcePlusX</strong>: same as before but with a one sided distribution (right):
    <div class="code">
     b = G.enforcePlusX(a, enforcedh, (supp,add)) <em>.or.</em> b = G.enforcePlusX(a, enforcedh, supp, add)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/enforcePlusX.py"> point addition on the right side of line x (array)</a>,
    <a href="Examples/Generator/enforcePlusXPT.py"> point addition on the right side of line x (pyTree)</a>.<br><br>


 <!--    For instance, enforce a region around a the j line which is at y=y0: -->
<!--     <div class="code"> -->
<!--       b = G.enforceY(a, y0, enforcedh, (supp,add)) <em>.or.</em> b = G.enforceY(a, y0, enforcedh, supp, add) -->
<!--     </div> -->
<!--     <em>Example of use: </em><a href="Examples/Generator/enforceY.py"> Point addition on both sides of line y (array)</a>, -->
<!--     <a href="Examples/Generator/enforceYPT.py"> point addition on both sides of line y (pyTree)</a>.<br> -->
<!--     <em>Example of use: </em><a href="Examples/Generator/enforceMoinsZ.py"> Point addition on the left side of line z (array)</a>.<br><br> -->

    <strong>G.enforceLine</strong>: enforce a curvilinear line defined by the array line in a distribution defined by the array a:
    <div class="code">
    b = G.enforceLine(a, line, enforcedh, (supp,add))
    </div>
    <em>Example of use: </em><a href="Examples/Generator/enforceLine.py"> line enforce (array)</a>,
    <a href="Examples/Generator/enforceLinePT.py"> line enforce (pyTree)</a>.<br><br>

    <strong>G.enforcePoint</strong>: enforce a point in the distribution. The index of enforced point is returned:
    <div class="code">
    ind = G.enforcePoint(a, x0)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/enforcePoint.py"> point addition (array)</a>,
    <a href="Examples/Generator/enforcePointPT.py"> point addition (pyTree)</a>.<br><br>

    <strong>G.enforceCurvature</strong>: enforce the curvature of an i-curve in a distribution defined by a.
    Power reflects the power of stretching:
    <div class="code">
      b = G.enforceCurvature(a, curve, power=0.5)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/enforceCurvature.py"> enforce curvature in a distribution (array)</a>,
    <a href="Examples/Generator/enforceCurvaturePT.py"> enforce curvature in a distribution (pyTree)</a>.<br><br>

    <strong>G.addPointInDistribution</strong>: add a point in a distribution at index ind:
    <div class="code">
      b = G.addPointInDistribution(a, ind)
    </div>
    <em>Example of use: </em><a href="Examples/Generator/addPointInDistribution.py"> point addition in a distribution (array)</a>,
    <a href="Examples/Generator/addPointInDistributionPT.py"> point addition in a distribution (pyTree)</a>.<br><br>

    <p></p>
    <h3>More general examples of use</h3>
    <p></p>
    <ul>
      <li><a href="Examples/Generator/naca.py"> Naca0012 mesh generation</a>
<!--       <li><a href="Examples/Generator/gencart2.py"> automatic Cartesian mesh generation</a> -->
    </ul>
    <hr>
    <a href="Userguide.html">Return to main userguide</a><p>
  </body>
</html>
