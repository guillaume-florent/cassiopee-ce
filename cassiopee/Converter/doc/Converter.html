<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Converter: CFD data conversion module</title>
    <link href="Cassiopee.css" rel="stylesheet" type="text/css">
    <link rel="icon" type="image/png" href="iconc.png"> </link>
    <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-31301505-1', 'auto');ga('send', 'pageview');</script>
  </head>

  <body>
    <h1>Converter: CFD Data Conversion</h1>
    <h2>Version: 2.4 (29/03/2017)</h2>
    <h2>Author: Onera</h2>
    <h2><a href="Latex/Converter.pdf" target="_self"><img src="pdf_logo.gif" alt="Download pdf version."></a></h2>
<HR>

    <h3>Preamble</h3>

    This module provides functions for CFD data conversion (both file format
    and grid topology). <br><br>

    This module is part of Cassiopee, a free open-source
    pre- and post-processor for CFD simulations.<br><br>

    This module can manipulate two different data structures:
    the first one is called an <strong>array</strong>, the second one is called
    a <strong>pyTree</strong>.<br>
    <ul>
    <li> An <b>array</b> is a simple definition of a mesh using classical
    numpy arrays.
    An array can be a
    <strong>structured</strong>
    array defined by a python list <b>[ 'x,y,z,...', an, ni, nj, nk ]</b>,
    where ni, nj, nk
    are the dimension of the grid and an is a (nfld, nixnjxnk) numpy array
    containing data (coordinates and fields). An array can also be an
    <strong>unstructured</strong> array defined by
    <b>[ 'x,y,z,...', an, cn, 'ELTTYPE' ]</b>,
    where cn is a numpy array storing the
    elements-to-nodes connectivity
    and an is a numpy array of data. If an stores fields on nodes, 'ELTTYPE'
    can be <b>'NODE', 'BAR', 'TRI', 'QUAD', 'TETRA', 'PYRA', 'PENTA',
    'HEXA'</b>. If an stores field on elements, 'ELTTYPE'
    can be <b>'NODE*', 'BAR*', 'TRI*', 'QUAD*', 'TETRA*', 'PYRA*', 'PENTA*',
    'HEXA*'</b>.
    Finally, an unstructured array can be of type <b>'NGON'</b>,
    describing meshes made of polyhedral elements.
    For those arrays, the connectivity cn is made of a faces-to-nodes
    connectivity (FN) and a elements-to-faces connectivity (EF). cn is then
    a flat numpy array [nfaces, sizeofFN, ..FN.., nelts, sizeofEF, ..EF..],
    where nfaces is the number of faces in mesh, nelts the number of elements
    in mesh. For each face, FN is [number of nodes, ..nodes indices..].
    For each element, EF is [number of faces, ..face indices..].<br>

    In this documentation, we note a or b an array,
    and A or B a list of arrays.<br>

    <b> Important note: </b>
    For accessing numpy arrays in Python, the first index corresponds to
    the variable number, the second index to the cell index.
    For instance: ar[0,0] for an 'x,y,z' array
    is variable x of first cell, ar[1,0] is variable y of
    first cell, and so on... For a structured array, the cell of index
    i,j,k will be accessed with index ind=i+j*ni+k*ni*nj, by ar[0,ind].<br>

    To use the array interface:
    <div class="code">
      import Converter as C
    </div>

    <li> A <b>pyTree</b> is a CGNS/Python tree, that is a mapping of the
    CGNS standard in Python, using lists and numpy arrays. Each node of the
    tree is a Python list defined by
    <b>[ 'name', ar, [...], 'CGNSType_t' ]</b>, where ar is the value
    stored by this node (ar can be a numpy array, a float64, an int32
    or a string), and [...] designates
    a list of nodes that are the children of the current node.<br>
    In this case, in the following, we note a or b a zone node,
    and A or B a list of zone nodes or a complete Python tree.<br>
    <b> Important note: </b>
    Numpy arrays stored in pyTrees stores only one variable for each node.
    Numpy arrays for a structured zone can be accessed by ar[i,j,k]
    and by ar[ind] for a unstructured zone.<br>

    To use the pyTree interface:
    <div class="code">
      import Converter.PyTree as C
    </div>
    </ul>

    <p></p>
    <h3>Name standardisation</h3>
    Some functions of Converter, Post and other modules perform specific
    treatments for given variables.
    For instance, the computeVariables function in the Post module can compute
    the pressure automatically if density and velocity are defined with
    their CGNS names. <br>
    Recognised names are CGNS names, but
    some alternative names are also recognised. <br>
    Names are described in the following table: <br>

  <table border="2" align="center" cellpadding="3" cellspacing="1" style="font-size:90%">

  <tr>
  <td>
   <strong>Description</strong>
    </td>
  <td>
   <strong>CGNS</strong>
    </td>
    <td>
     <strong>Alternative names</strong>
    </td></tr>

  <tr>
  <td>
   Coordinate in x direction
    </td>
  <td>
   CoordinateX
    </td>

    <td>
     x, X
    </td></tr>
  <tr>
  <td>
   Coordinate in y direction
    </td>
  <td>
   CoordinateY
    </td>

    <td>
     y, Y
    </td></tr>
  <tr>
  <td>
   Coordinate in z direction
    </td>
  <td>
   CoordinateZ
    </td>
    <td>
     z, Z
    </td></tr>
  <tr>
  <td>
   Density
    </td>
  <td>
   Density
    </td>

    <td>
     ro
    </td></tr>
  <tr>
  <td>
   Momentum in x direction
    </td>
  <td>
   MomentumX
    </td>

    <td>
     rou, rovx
    </td></tr>
  <tr>
  <td>
   Momentum in y direction
    </td>
  <td>
   MomentumY
    </td>

    <td>
     rov, rovy
    </td></tr>
  <tr>
  <td>
   Momentum in z direction
    </td>
  <td>
   MomentumZ
    </td>

    <td>
     row, rovz
    </td></tr>
  <tr>
  <td>
   Density times total energy
    </td>
  <td>
   EnergyStagnationDensity
    </td>

    <td>
     roE
    </td></tr>
  <tr>
  <td>
   Density times turbulence kinetic energy
    </td>
  <td>
   TurbulentEnergyKineticDensity
    </td>

    <td>
     rok
    </td></tr>
  <tr>
  <td>
   Density times dissipation rate of turbulence kinetic energy
    </td>
  <td>
   TurbulentDissipationDensity
    </td>
    <td>
     roeps
    </td></tr>
  <tr> <td>
   Static pressure
  </td>
  <td>
  Pressure
  </td>
   <td>
   </td></tr>
  <tr> <td>
   Dynamic pressure
  </td>
  <td>
  PressureDynamic
  </td>
   <td>
   </td></tr>
  <tr>
  <td>
   Static temperature
  </td>
  <td>
  Temperature
  </td>
   <td>
   </td></tr>
  <tr>
  <td>
   Enthalpy
  </td>
  <td>
  Enthalpy
  </td>
   <td>
   </td></tr>
  <tr>
  <td>
   Entropy
  </td>
  <td>
  Entropy
  </td>
   <td>
   </td></tr>
  <tr> <td>
   Stagnation pressure
  </td>
  <td>
  PressureStagnation
  </td>
   <td>
   </td></tr>
  <tr> <td>
   Stagnation temperature
  </td>
  <td>
  TemperatureStagnation
  </td>
   <td>
   </td></tr>
  <tr>  <td>
  x-component of the absolute velocity
  </td>
  <td>
  VelocityX
  </td>
   <td>
  </td></tr>
   <tr>  <td>
   y-component of the absolute velocity
  </td>
  <td>
  VelocityY
  </td>
   <td>
   </td></tr>
  <tr>  <td>
  z-component of the absolute velocity
  </td>
  <td>
  VelocityZ
  </td>
   <td>
  </td></tr>
  <tr>  <td>
  Absolute velocity magnitude
  </td>
  <td>
  VelocityMagnitude
  </td>
   <td>
  </td></tr>
  <tr> <td>
   Absolute Mach number
  </td>
  <td>
  Mach
  </td>
   <td>
   </td></tr>
   <tr><td>
   Molecular viscosity
  </td>
  <td>
  ViscosityMolecular
  </td>
   <td>
   </td></tr>
  <tr> <td>
   Cell Nature Field (0:blanked, 1:discretised, 2:interpolated)
    </td>
  <td>

    </td>

    <td>
     cellN, cellnf
    </td></tr>
  <tr>
  <td>
   Cell Nature Field (0:blanked, 1:discretised, -Id:-interpolation block Id)
    </td>
  <td>

    </td>
    <td>
     cellNF, cellnf, cellNF, ichim
    </td></tr>
  <tr> <td>
   Cell Status (-1:orphan, 0:blanked, 1:discretised, 2:interpolated explicitly, 3:extrapolated, 4:interpolated implicitly)
    </td>
  <td>

    </td>

    <td>
     status
    </td></tr>
    </table>

    <p></p>
    <h3>Array creation and manipulations</h3>
    <p></p>

    <strong>C.array</strong>:
    create a structured array containing variables x,y,z on a nixnjxnk grid:
    <div class="code">
      a = C.array('x,y,z', ni, nj, nk)
    </div>

    Create an unstructured array containing variables x,y,z on a grid
    containing np points and ne elements of type ELTTYPE (=NODE, BAR, TRI, QUAD, TETRA, PYRA, PENTA, HEXA, NGON):
    <div class="code">
      a = C.array('x,y,z', np, ne, ELTTYPE)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/arrayK.py"> array creation (array).</a> <br><br>

    <strong>C.getValue</strong>:
    return the list of values defined in array a for point of index ind
    (for both structured and unstructured arrays). For structured arrays, you
    can specify (i,j,k) instead of ind. For unstructured arrays, the index ind
    corresponds to the location type of point defining array a: for instance,
    if array a describes a field at element vertices, ind is a vertex index
    (ind starts at 0 and (i,j,k) start at 1):
    <div class="code">
      v = C.getValue(a, ind)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getValue.py"> get values for a given grid index (array)</a>.<br><br>

    <strong>C.setValue</strong>:
    set the values of one point of index ind in array a. v must be a list corresponding to the variables stored in array a:
    <div class="code">
      C.setValue(a, ind, v)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/setValue.py"> set values for a given grid index (array).</a><br><br>

    <strong>C.addVars</strong>:
    add variable(s) to an array. Variables argument can be a string
    name ('ro') or a list of string names (['ro', 'rou']):
    <div class="code">
      b = C.addVars(a, 'ro') <em>.or.</em> B = C.addVars(A, 'ro')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addVar.py"> variables adding (array)</a>.<br><br>

    <strong>C.addVars</strong>:
    concatenate array fields with the same dimensions.
    Variables defined by a list of arrays are put in the same array:
    <div class="code">
    f = C.addVars([a, b, c])
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addVars.py"> many variables adding (array).</a> <br><br>

    <strong>C.copy</strong>:
    copy an array (return a new duplicated array):
    <div class="code">
      b = C.copy(a) <em>.or.</em> B = C.copy(A)
    </div>
     <em>Example of use: </em><a href="Examples/Converter/copya.py"> array copy (array).</a> <br><br>

    <p></p>
    <h3>pyTree creation and manipulations</h3>
    <p></p>

    <strong>C.newPyTree</strong>:
    create a new pyTree. You can specify base names, cell dimension in base,  and attach zone nodes
    eventually:
    <div class="code">
    A = C.newPyTree(['Base1', 2, 'Base2', 3]) <em>.or.</em> A = C.newPyTree(['Base1', z1, z2])
    </div>
    <em>Example of use: </em><a href="Examples/Converter/newPyTree.py"> pyTree creation (pyTree).</a> <br><br>

    <strong>C.getNobOfBase</strong>:
    get the number of a given base a in topTree base list, such that
    topTree[2][nob] = a:
    <div class="code">
    nob = C.getNobOfBase(a, topTree)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getNobOfBasePT.py"> get base number (pyTree).</a> <br><br>

    <strong>C.getNobNozOfZone</strong>:
    get the number (nob, noz) of a given zone a in topTree base and zone list ,
    such that topTree[2][nob][2][noz] = a:
    <div class="code">
      (nob, noz) = C.getNobNozOfZone(a, topTree)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getNobNozOfZonePT.py">  get base and zone number (pyTree).</a> <br><br>

    <strong>C.breakConnectivity</strong>:
    break a multi-element zone (unstructured) into single element zones:
    <div class="code">
    B = C.breakConnectivity(a) <em>.or.</em> B = C.breakConnectivity(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/breakConnectivityPT.py">  break a multiple connectivity zone into two zones (pyTree).</a> <br><br>

    <strong>C.mergeConnectivity</strong>:
    merge two zones (unstructured) into a single zone with a multiple
    connectivity. If boundary=1, b will be a BC connectivity in a (b must be
    a subzone of a), if boundary=0, b will be a element connectivity:
    <div class="code">
    a = C.mergeConnectivity(a, b, boundary=0)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/mergeConnectivityPT.py">  merge two zones into a multiple connectivity zone (pyTree).</a> <br><br>

    <strong>C.mergeTrees</strong>:
    merge two trees in one. Only basis of B are added to A:
    <div class="code">
      D = C.mergeTrees(A, B)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/mergeTrees.py"> merge of pyTrees (pyTree).</a> <br><br>

    <strong>C.deleteEmptyZones</strong>:
    delete structured zones with a null ni, nj or nk, delete unstructured
    zones with a null number of nodes or elements:
    <div class="code">
      B = C.deleteEmptyZones(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/deleteEmptyZones.py"> delete empty zones (pyTree).</a> <br><br>

    <strong>C.addBase2PyTree</strong>:
    add a base named 'baseName' to a pyTree. Third argument specifies the
    cell dimension (cellDim=3 for volume meshes, cellDim=2 for surface meshes):
    <div class="code">
    B = C.addBase2PyTree(A, baseName, cellDim=3)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addBase2PyTree.py"> add a base to pyTree (pyTree).</a> <br><br>

    <strong>C.addState</strong>:
    add a FlowEquation or a ReferenceState data to a base or a zone or a node:
    <div class="code">
    B = C.addState(A, state, value)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addStatePT.py"> add a state to a base (pyTree).</a> <br><br>
    Add a full ReferenceState data to a base or a zone or a node:
    <div class="code">
    B = C.addState(A, MInf=0.5, alphaZ=0., alphaY=0., ReInf=1.e8, MutSMuInf=0.2, TurbLevelInf=1.e-4)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addState2PT.py"> add a state to a base (pyTree).</a> <br><br>

    <strong>C.addChimera2Base</strong>:
    add Chimera settings data to a base. Settings are added in
    a .Solver#Chimera user defined node:
    <div class="code">
    B = C.addChimera2Base(A, setting, value)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addChimera2Base.py"> add Chimera settings to a base (pyTree).</a> <br><br>

    <strong>C.addBC2Zone</strong>:
    add a physical boundary condition (BC) or a grid connectivity (GC) to a structured/basic element/NGON zone
    of a PyTree.
    Parameter bndName is the name of the BC or GC.
    Parameter bndType is the type of BC, according to the CGNS Standard or 'BCMatch' for a 1-to-1 abutting GC,
    'BCNearMatch' for 'n-to-m' abutting GC (only for structured grids), 'BCOverlap' for an overset GC, or
    'FamilySpecified:FAMILY' for a BC specified in a family BC named FAMILY.
    Data is optional data that will be stored in a BCDataSet.<br><br>

    For structured grids, parameter 'range' specifies the window where the BC is applied.
    It can be defined by a list of indices [imin, imax, jmin, jmax, kmin, kmax] or by 'imin', 'jmin', ...
    if the BC is defined on the whole window ('imin' stands for i=1, 'imax' for i=imax).
    A physical BC for a structured grid is defined by:
    <div class="code">
    b = C.addBC2Zone(a, bndName, bndType, range, data=None)
    </div>
    For a 1-to-1 abutting GC, donor zone and range and transformation must be specified:
    <div class="code">
    b = C.addBC2Zone(a, bndName, 'BCMatch', range, zoneDonor=donorZone, rangeDonor=donorRange, trirac=[-1,2,3])
    </div>
    For periodic 1-to-1 GC, you must specify rotationCenter, rotationAngle and translation:
    <div class="code">
    b = C.addBC2Zone(a, bndName, 'BCMatch', range, zoneDonor=donorZone, rangeDonor=donorRange, trirac=[-1,2,3],
    rotationCenter=(0,0,0), rotationAngle(0,0,25.), translation=(0,0,0))
    </div>
    For an overlap GC, donor zones can be provided as a list of zones or a list of zone names (optional).
    If the window range defines an overset GC and a physical BC, then 'doubly_defined' must be set for the
    'rangeDonor' parameter.
    <div class="code">
    b = C.addBC2Zone(a, bndName, 'BCOverlap', range, zoneDonor=donorZones, rangeDonor='doubly_defined')
    </div>
    <br>
    For basic element unstructured zones, the location of the BC/GC can be specified either by a list of faces
    defined by 'faceList', either by 'elementList' or 'elementRange' referencing an existing boundary
    connectivity, or by a subzone:
    <div class="code">
      b = C.addBC2Zone(a, bndName, bndType, faceList=[], data=None)<em>.or.</em>
      b = C.addBC2Zone(a, bndName, bndType, elementList=[], data=None) <em>.or.</em>
      b = C.addBC2Zone(a, bndName, bndType, elementRange=[], data=None) <em>.or.</em>
      b = C.addBC2Zone(a, bndName, bndType, subzone=z, data=None)
    </div>
    <br>
    For NGON zones, only faceList or subzone can be used:
    <div class="code">
    b = C.addBC2Zone(a, bndName, bndType, faceList=[], data=None)<em>.or.</em>
    b = C.addBC2Zone(a, bndName, bndType, subzone=z, data=None)
    </div>
    <br>
    <em>Example of use: </em><a href="Examples/Converter/addBC2Zone.py"> add a boundary condition to a structured zone node of a pyTree.</a> <br>
    <em>Example of use: </em><a href="Examples/Converter/addBC2ZoneU.py"> add a boundary condition to a NGON zone node of a pyTree.</a> <br><br>

    <strong>C.fillEmptyBCWith</strong>:
    fill empty boundary conditions of a structured tree/base/list of
    zones/zone with the given boundary condition. Parameter dim can be 2 or 3:
    <div class="code">
    b = C.fillEmptyBCWith(a, bndName, bndType, dim=3) <em>.or.</em>  B = C.fillEmptyBCWith(A, bndName, bndType, dim=3)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/fillEmptyBCWith.py"> fill missing boundary conditions (pyTree).</a> <br><br>

    <strong>C.rmBCOfType</strong>:
    remove all boundaries of a given type from a pyTree. bndType can also
    be a family BC name ('FamilySpecified:FAMILY'):
    <div class="code">
    b = C.rmBCOfType(a, 'BCWall') <em>.or.</em> B = C.rmBCOfType(A, 'BCWall')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/rmBCOfType.py"> remove wall boundaries from a pyTree (pyTree).</a> <br><br>

    <strong>C.rmBCOfName</strong>:
    remove the boundary of given name from a pyTree. bndName accepts
    wildcard and can also be a family BC name ('FamilySpecified:FAMILY'):
    <div class="code">
    b = C.rmBCOfName(a, 'wall*') <em>.or.</em> B = C.rmBCOfName(A, 'wall*')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/rmBCOfNamePT.py"> remove boundaries from a pyTree by name (pyTree).</a> <br><br>

    <strong>C.extractBCOfType</strong>:
    extract all boundaries of a given type from a pyTree,
    return a list of zones. bndType can also be a family BC name ('FamilySpecified:FAMILY):
    <div class="code">
    Z = C.extractBCOfType(a, 'BCWall') <em>.or.</em> Z = C.extractBCOfType(A, 'BCWall')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/extractBCOfTypePT.py"> extract wall boundaries from a pyTree (pyTree).</a> <br><br>

    <strong>C.extractBCOfName</strong>:
    extract all boundaries of a given name from a pyTree, return a list
    of zones. bndName accepts wildcards or can be a family name ('FamilySpecified:FAMILY'):
     <div class="code">
    Z = C.extractBCOfName(a, 'wall1') <em>.or.</em> Z = C.extractBCOfName(A, 'wall1')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/extractBCOfNamePT.py"> extract given named boundaries from a pyTree (pyTree).</a> <br><br>

    <strong>C.getEmptyBC</strong>:
    return undefined boundary conditions for a zone node, a list
    of zone nodes or a complete pyTree, as a list of the range
    [imin,imax,jmin,jmax,kmin,kmax] of undefined boundaries for structured
    zones and as a list of face indices for unstructured zones.
    Lists are empty ([[],...,[]]) if all the boundary conditions
    have been defined. Parameter dim can be 2 or 3. For unstructured grids,
    undefined boundaries can be split if the angle between neighbouring
    elements exceeds splitFactor in degrees (default no split):
    <div class="code">
     wins = C.getEmptyBC(a, dim=3, splitFactor=180.) <em>.or.</em> wins = C.getEmptyBC(A, dim=3, splitFactor=180.)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getEmptyBC.py"> detection of undefined BC in a pyTree (pyTree).</a><br><br>

    <strong>C.getConnectedZones</strong>:
    get zones connected to a given zone a by 'BCMatch' or 'BCNearMatch' or 'all' (defined in zone GridConnectivity):
     <div class="code">
     Z = C.getConnectedZones(a, topTree, type='all') <em>.or.</em> Z = C.getConnectedZones(A, topTree, type='all')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getConnectedZonesPT.py"> return connected zones (pyTree).</a><br><br>

    <strong>C.addFamily2Base</strong>:
    add a family node to a base node of a tree. If this node defines
    a BC type, bndType must be defined:
    <div class="code">
    B = C.addFamily2Base(A, familyName, bndType=None)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addFamily2Base.py"> add a family name to a Python tree (pyTree).</a><br><br>

    <strong>C.tagWithFamily</strong>:
    Tag a zone node or a BC node a with a family name:
    <div class="code">
    b = C.tagWithFamily(a, familyName)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/tagWithFamilyPT.py"> tag zones with a family name (pyTree).</a> <br><br>

    <strong>C.getFamilyZones</strong>:
    get all zones of a family name:
    <div class="code">
    b = C.getFamilyZones(a, familyName)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getFamilyZonesPT.py"> get all zones of a family name (pyTree).</a> <br><br>

    <strong>C.getFamilyBCs</strong>:
    get all BC nodes of a given familyName:
    <div class="code">
    b = C.getFamilyBCs(a, familyName)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getFamilyBCsPT.py"> get all BC nodes with a BC family name (pyTree).</a> <br><br>

    <strong>C.getFamilyZoneNames</strong>:
    get all family zone names in A (A must be a base node or a tree node):
    <div class="code">
    names = C.getFamilyZoneNames(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getFamilyZoneNamesPT.py"> get family BC names in a tree (pyTree).</a> <br><br>

    <strong>C.getFamilyBCNamesOfType</strong>:
    get all family BC names of this type (A must be a base node or a tree node):
    <div class="code">
    names = C.getFamilyBCNamesOfType(A, bndType=None)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getFamilyBCNamesOfTypePT.py"> get family BC names in a tree (pyTree).</a> <br><br>

    <strong>C.rmNodes</strong>:
    remove nodes named 'name' from a for each zone:
    <div class="code">
    b = C.rmNodes(a, name) <em>.or.</em> B = C.rmNodes(A, name)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/rmNodes.py"> remove specified nodes from a pyTree (pyTree).</a> <br><br>

    <strong>C.getValue</strong>:
    return the list of values defined in a zone a for point of index ind
    (for both structured and unstructured zones).
    For structured zones, you can specify (i,j,k) instead of ind.
    For unstructured zones, the index ind
    corresponds to the location type of point defining zone a:
    for instance, if
    a describes a field at element vertices, ind is a vertex index.
    var is the name of the variable:
    <div class="code">
      v = C.getValue(a, var, ind)
    </div>
    ind starts at 0 and (i,j,k) start at 1. <br>
    <em>Example of use: </em><a href="Examples/Converter/getValuePT.py"> get values for a given grid index (pyTree)</a>.<br><br>

    <strong>C.setValue</strong>:
    set the values of one point of index ind in a zone a.
    var is the name of the variables to be modified, value can be a
    float or a list of floats
    corresponding to the values of the variables to be modified:
    <div class="code">
      C.setValue(a, var, ind, value)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/setValuePT.py"> set values for a given grid index (pyTree)</a>.<br><br>

    <strong>C.setPartialFields</strong>:
    set the values for a given list of indices. Field values are
    given as a list of arrays in F (one array for each zone), indices
    are given as a list of numpys in I (one numpy for each zone), loc can
    be 'nodes' or 'centers':
    <div class="code">
    b = C.setPartialFields(a, F, I, loc='nodes')  <em>.or.</em> B = C.setPartialFields(A, F, I, loc='nodes')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/setPartialFieldsPT.py"> set values for a list of indices (pyTree)</a>.<br><br>

    <strong>C.setPartialFields1</strong>:
    set the values for a given list of indices. Field values are
    given as a list of numpys in F (a list of numpys for each zone and for
    each field), indices are given as a list of numpys in I (one numpy
    for each zone), loc can be 'nodes' or 'centers':
    <div class="code">
    b = C.setPartialFields1(a, F, I, loc='nodes')  <em>.or.</em> B = C.setPartialFields1(A, F, I, loc='nodes')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/setPartialFields1PT.py"> set values for a list of indices (pyTree)</a>.<br><br>

    <strong>C.addVars</strong>:
    add a variable(s) to a zone. var is a string name or a list
    of string names (e.g. 'Density',...), variable localisation
    ('nodes' or 'centers') can be specified in var:
    <div class="code">
      b = C.addVars(a, var) <em>.or.</em> B = C.addVars(A, var)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addVarsPT.py"> variables adding (pyTree)</a>.<br><br>

    <strong>C.fillMissingVariables</strong>:
    fill FlowSolution_t nodes with variables defined in a zone, such that all the zones have the same variables:
    <div class="code">
      b = C.fillMissingVariables(a)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/fillMissingVariablesPT.py"> variable filling (pyTree)</a>.<br><br>

    <strong>C.cpVars</strong>:
    copy a variable from zone a1, with name var1, to zone a2, with name var2.
    The var location must be coherent:
    <div class="code">
     b = C.cpVars(a1, var1, a2, var2)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/cpVars.py"> copy a variable (pyTree)</a>.<br><br>

    <strong>C.printTree</strong>:
    pretty print a pyTree to screen or in a file:
    <div class="code">
    C.printTree(A, file=None)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/printTree2PT.py"> print a pyTree to screen (pyTree).</a> <br><br>

    <p></p>
    <h3>Array / pyTree common manipulations</h3>
    <p></p>

    <strong>C.getVarNames</strong>:
    return the list of variable names contained in a. Localization of variables can be specified ('nodes', 'centers', 'both'):
    <div class="code">
    V = C.getVarNames(a, excludeXYZ=False, loc='both') <em>.or.</em> V = C.getVarNames(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getVarNames.py"> get variable names (array)</a>,
    <a href="Examples/Converter/getVarNamesPT.py"> get variable names (pyTree)</a>.<br><br>

     <strong>C.isNamePresent</strong>:
    return -1 if A doesn't contain varName, 0 if at least one zone in A
     contains varName, 1 if all zones in A contain varName:
    <div class="code">
    ret = C.isNamePresent(a, varName) <em>.or.</em> ret = C.isNamePresent(A, varName)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/isNamePresent.py"> is variable present? (array)</a>,
    <a href="Examples/Converter/isNamePresentPT.py"> is variable present? (pyTree)</a>.<br><br>

    <strong>C.getNPts</strong>:
    return the number of points in a:
    <div class="code">
      npts = C.getNpts(a) <em>.or.</em> npts = C.getNpts(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getNPts.py"> get the number of points of a given array (array)</a>, <a href="Examples/Converter/getNPtsPT.py"> get the number of points of a given pyTree (pyTree)</a>.<br><br>

    <strong>C.getNCells</strong>:
    return the number of cells in a:
    <div class="code">
      ncells = C.getNCells(a) <em>.or.</em> ncells = C.getNCells(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getNCells.py"> get the number of cells of a given array (array)</a>, <a href="Examples/Converter/getNCellsPT.py"> get the number of cells of a given pyTree (pyTree)</a>.<br><br>

    <strong>C.initVars</strong>:
    init variable given by a string to a constant value val:
    <div class="code">
    b = C.initVars(a, 'cellN', val) <em>.or.</em> B = C.initVars(A, 'cellN', val)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/initVars.py"> variable initialisation (array)</a>,
    <a href="Examples/Converter/initVarsPT.py"> variable initialisation (pyTree)</a>.<br>

    Init a variable (named 'x') with a function f. Function f has two arguments here, named 'x','y'. Variables location can not be mixed:
    <div class="code">
    b = C.initVars(a, 'x', f, ['x','y']) <em>.or.</em> B = C.initVars(A, 'x', f, ['x','y'])
    </div>
    <em>Example of use: </em><a href="Examples/Converter/initVar.py"> variable initialisation by a function.</a> <br>

    Init a variable by a formula string. Variables must be separated by {}.
    Variables location can not be mixed:
     <div class="code">
    b = C.initVars(a, '{Density} = 3 * {x}') <em>.or.</em> B = C.initVars(A, '{Density} = 3 * {x}')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/initVarsByEq.py"> variable initialisation by a formula (array).</a> ,
    <a href="Examples/Converter/initVarsByEqPT.py"> variable initialisation by a formula (pyTree)</a>.<br><br>

    <strong>C.extractVars</strong>:
    extract variables named 'F','G' from a (other variables are removed):
    <div class="code">
      b = C.extractVars(a, ['F','G']) <em>.or.</em> B = C.extractVars(A, ['F','G'])
    </div>
    <em>Example of use: </em><a href="Examples/Converter/extractVars.py"> variables extraction (array)</a>,
    <a href="Examples/Converter/extractVarsPT.py"> variables extraction (pyTree).</a> <br><br>

    <strong>C.rmVars</strong>:
    remove a variable(s). var is a string name or a list of string names:
    <div class="code">
      b = C.rmVars(a, var) <em>.or.</em> B = C.rmVars(A, var)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/rmVars.py"> remove a variable (array)</a>,
    </em><a href="Examples/Converter/rmVarsPT.py"> remove a variable (pyTree)</a>.<br><br>

    <strong>C.convertArray2Tetra</strong>:
    create tetra unstructured array from an array. 2D elements are made triangular, else they are made tetrahedral.
     If split='simple', conversion does not create new points. If split='withBarycenters', barycenters of elements and faces are added:
    <div class="code">
      b = C.convertArray2Tetra(a, split='simple') <em>.or.</em> B = C.convertArray2Tetra(A, split='simple')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convertStruct2Tetra.py"> tetrahedral array creation from structured array (array)</a>,
     <a href="Examples/Converter/convertArray2TetraPT.py"> tetrahedral zone creation from structured zone (pyTree)</a>.<br>
    <em>Example of use: </em><a href="Examples/Converter/convertHexa2Tetra.py"> tetrahedral array creation from hexahedral array (array)</a>.<br>
    <em>Example of use: </em><a href="Examples/Converter/convertPrism2Tetra.py"> tetrahedral array creation from prismatic array (array)</a>.<br><br>

    <strong>C.convertArray2Hexa</strong>:
    Create hexa unstructured array from an array. 2D elements are made quadrangular, else they are made hexahedral:
    <div class="code">
      b = C.convertArray2Hexa(a) <em>.or.</em> B = C.convertArray2Hexa(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convertStruct2Hexa.py"> hexahedral array creation from a structured array (array)</a>,
    <a href="Examples/Converter/convertArray2HexaPT.py"> hexahedral zone creation from a structured zone (pyTree)</a>.<br><br>

    <strong>C.convertArray2NGon</strong>:
    create an NGON array from an array:
    <div class="code">
    b = C.convertArray2NGon(a) <em>.or.</em> B = C.convertArray2NGon(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convertArray2NGon.py"> NGON array creation from a structured array (array)</a>,
    <a href="Examples/Converter/convertArray2NGonPT.py"> NGON zone creation from a structured zone (pyTree)</a>.<br><br>

    <strong>C.convertArray2Node</strong>:
    create a node array from an array (discarding any connectivity):
    <div class="code">
      b = C.convertArray2Node(a) <em>.or.</em> B = C.convertArray2Node(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convertArray2Node.py"> node array creation from a structured array (array)</a>,
     <a href="Examples/Converter/convertArray2NodePT.py"> node zone creation from a structured zone (pyTree)</a>.<br><br>

    <strong>C.convertBAR2Struct</strong>:
    create a structured 1D array from a BAR array. The BAR array must not contain branches:
    <div class="code">
      b = C.convertBAR2Struct(a) <em>.or.</em> B = C.convertBAR2Struct(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convertBAR2Struct.py"> conversion from a BAR to an i-array (array)</a>,
     <a href="Examples/Converter/convertBAR2StructPT.py"> conversion from a BAR zone to a structured zone (pyTree)</a>.<br><br>

     <strong>C.convertTri2Quad</strong>:
     convert a TRI-array to a QUAD-array. Neighbouring cells with an
     angle lower than alpha can be merged.
     It returns the QUAD-array b and
     the rest of not merged cells in a TRI-array c:
     <div class="code">
      b, c = C.convertTri2Quad(a, alpha=30.) <em>.or.</em> B, C = C.convertTri2Quad(A, alpha=30.)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convertTri2Quad.py"> conversion from a TRI to QUAD (array)</a>,
     <a href="Examples/Converter/convertTri2QuadPT.py"> conversion from TRI zone to QUAD zone (pyTree)</a>.<br><br>

    <strong>C.conformizeNGon</strong>:
    conformize the cell faces of a NGon, such that a face of a cell corresponds
    to a unique face of another cell:
     <div class="code">
      b = C.conformizeNGon(a, tol=1.e-6) <em>.or.</em> B = C.conformizeNGon(A, tol=1.e-6)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/conformizeNGon.py"> NGon conformization (array)</a>,
     <a href="Examples/Converter/conformizeNGonPT.py"> NGon conformization (pyTree)</a>.<br><br>

    <strong>C.node2Center</strong>:
    convert data (grid coordinates and solution), defined at nodes in a,
    to centers:
    <div class="code">
    b = C.node2Center(a) <em>.or.</em> B = C.node2Center(A)
    </div>
    When using the pyTree interface, a varname can be additionaly specified.
    Then, only the variable 'varname'
    is computed at centers and set in returned zone
    FlowSolution#Centers location:
    <div class="code">
    b = C.node2Center(a, 'Density') <em>.or.</em> B = C.node2Center(A, 'Density')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/node2Center.py"> node to center conversion (array)</a>,
    <a href="Examples/Converter/node2CenterPT.py"> node to center conversion (pyTree)</a>.<br><br>

    <strong>C.center2Node</strong>:
    Change data, defined at centers in a, to nodes. cellNType indicates the
    treatement for blanked points when cellN field is present. cellNType=0, means that, if a node receives at least one cellN=0 value from a center, its cellN is set to 0. cellNType=1 means that, only if all values of neighbouring centers are cellN=0, its cellN is set to 0:
    <div class="code">
      b = C.center2Node(a, cellNType=0) <em>.or.</em> B = C.center2Node(A, cellNType=0)
    </div>
    When using the pyTree interface, a varname can be additionaly specified.
    Then, only the variable 'varname' is computed at nodes and set in zone
    FlowSolution location:
    <div class="code">
    b = C.center2Node(a, 'centers:Density') <em>.or.</em> B = C.center2Node(A, 'centers:Density')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/center2Node.py"> center to node conversion (array)</a>,
     <a href="Examples/Converter/center2NodePT.py"> center to node conversion (pyTree)</a>.<br><br>

    <strong>C.node2ExtCenters</strong>:
    Convert grid coordinates, defined at nodes in a, to extended centers:
    <div class="code">
    b = C.node2ExtCenter(a) <em>.or.</em> B = C.node2ExtCenter(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/node2ExtCenter.py"> node to extended centers conversion (array)</a>,
    <a href="Examples/Converter/node2ExtCenterPT.py"> nodes to extended centers conversion (pyTree)</a>.<br><br>

    <p></p>
    <h3>Array / pyTree analysis</h3>
    <p></p>

    <strong>C.diffArrays</strong>:
    given a solution A and a solution B both defined on the same mesh,
    return the differences:
    <div class="code">
    C = C.diffArrays(A, B)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/diffArrays.py"> diffing (array)</a>,
    </em><a href="Examples/Converter/diffArraysPT.py"> diffing (pyTree)</a>.<br><br>

    <strong>C.getArgMin</strong>:
    return the field value where variable 'ro' is minimum:
    <div class="code">
    min = C.getArgMin(a, 'ro') <em>.or.</em> min = C.getArgMin(A, 'ro')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getArgMin.py"> get the field value where x is minimum (array)</a>,
    </em><a href="Examples/Converter/getArgMinPT.py"> get the field value where x is minimum (pyTree)</a>.<br><br>

    <strong>C.getArgMax</strong>:
    Return the field value where variable 'ro' is maximum:
    <div class="code">
    max = C.getArgMax(a, 'ro') <em>.or.</em> max = C.getArgMax(A, 'ro')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getArgMax.py"> get the field value where x is maximum (array)</a>,
    </em><a href="Examples/Converter/getArgMaxPT.py"> get the field value where x is maximum (pyTree)</a>.<br><br>

    <strong>C.getMinValue</strong>:
    return the min value of variable 'ro':
    <div class="code">
    min = C.getMinValue(a, 'ro') <em>.or.</em> min = C.getMinValue(A, 'ro')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getMinValue.py"> get the min value of x in a mesh (array)</a>,
    </em><a href="Examples/Converter/getMinValuePT.py"> get the min value of x in a mesh (pyTree)</a>.<br><br>

    <strong>C.getMaxValue</strong>:
    return the max value of variable 'ro':
    <div class="code">
    max = C.getMaxValue(a, 'ro') <em>.or.</em> max = C.getMaxValue(A, 'ro')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getMaxValue.py"> get the max value of x in a mesh (array)</a>,
    </em><a href="Examples/Converter/getMaxValuePT.py"> get the max value of x in a mesh (pyTree)</a>.<br><br>

    <strong>C.getMeanValue</strong>:
    return the mean value of variable 'ro':
    <div class="code">
    mean = C.getMeanValue(a, 'ro') <em>.or.</em> mean = C.getMeanValue(A, 'ro')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getMeanValue.py"> get the mean value of x in a mesh (array)</a>,
    </em><a href="Examples/Converter/getMeanValuePT.py"> get the mean value of x in a mesh (pyTree)</a>.<br><br>

    <strong>C.getMeanRangeValue</strong>:
    return the mean value of variable 'ro' for the 20% biggest values (between 80% and 100%):
    <div class="code">
    mean = C.getMeanRangeValue(a, 'ro', 0.8, 1.) <em>.or.</em> mean = C.getMeanRangeValue(A, 'ro', 0.8, 1.)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getMeanRangeValue.py"> get the mean value of x in a sorted range of values (array)</a>,
    </em><a href="Examples/Converter/getMeanRangeValuePT.py"> get the mean value of x in a sorted range of values (pyTree)</a>.<br><br>

    <strong>C.normL0, C.normL2</strong>:
    L0 and L2 norms of a field defined in an array can be extracted. If cellnature field is defined in the array, then blanked points are not taken into account into the computation of the norm:
    <div class="code">
    L0norm = C.normL0(a, 'ro') <em>.or.</em> L0norm = C.normL0(A, 'ro')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/normL0.py"> get the L0 norm of variable x (array)</a>,
    </em><a href="Examples/Converter/normL0PT.py"> get the L0 norm of variable x (pyTree).</a><br>
    <div class="code">
    L2norm = C.normL2(a, 'ro') <em>.or.</em> L2norm = C.normL2(A, 'ro')
    </div>
<em>Example of use: </em><a href="Examples/Converter/normL2.py"> get the L2 norm of a field (array)</a>,
</em><a href="Examples/Converter/normL2PT.py"> get the L2 norm of a field (pyTree)</a>.<br><br>

    <strong>C.normalize</strong>:
    Normalize a vector defined by its 3 vector coordinates. The vector component values are modified:
    <div class="code">
    b = C.normalize(a, ['sx', 'sy', 'sz']) <em>.or.</em> B = C.normalize(A, ['sx', 'sy', 'sz'])
    </div>
    <em>Example of use: </em><a href="Examples/Converter/normalize.py"> normalize a vector (array)</a>,
    <a href="Examples/Converter/normalizePT.py"> normalize a vector located at centers (pyTree)</a>.<br><br>

    <strong>C.magnitude</strong>:
    get the magnitude of a vector for each point of array:
    <div class="code">
    b = C.magnitude(a, ['sx', 'sy', 'sz']) <em>.or.</em> B = C.magnitude(A, ['sx', 'sy', 'sz'])
    </div>
    <em>Example of use: </em><a href="Examples/Converter/magnitude.py"> get the magnitude of a vector (array)</a>,
    <a href="Examples/Converter/magnitudePT.py"> get the magnitude of a vector (pyTree)</a>.<br><br>

    <strong>C.randomizeVar</strong>:
    randomize a variable of name varname. The modified field is bounded by [f-deltamin,f+deltamax] where f is the local field.
    <div class="code">
    b = C.randomizeVar(a, varname, deltamin, deltamax) <em>.or.</em> B = C.randomizeVar(A, varname, deltamin,deltamax)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/randomizeVar.py"> randomize a field (array)</a>,
    <a href="Examples/Converter/randomizeVarPT.py"> randomize a field (pyTree)</a>.<br><br>

    <p></p>
    <h3>Array / pyTree conversion</h3>
    <p></p>

    <strong>C.convertPyTree2ZoneNames</strong>:
    return the list of zone paths (strings) contained in a Python tree:
    <div class="code">
    P = C.convertPyTree2ZoneNames(T)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convertPyTree2ZoneNames.py"> zone name extraction from a Python tree (pyTree).</a><br><br>

    <strong>C.convertPyTree2Array</strong>:
    convert a Python tree node to an array.
    One have to provide
    the path of the corresponding node and the Python tree:
    <div class="code">
    a = C.convertPyTree2Array("Zone-001/GridCoordinates/CoordinateX", T)
    </div>
     <em>Example of use: </em><a href="Examples/Converter/convertPyTree2Array.py"> node of Python tree to array conversion (pyTree).</a> <br><br>

<!--     Set array a to a pyTree path location: -->
<!--     <div class="code"> -->
<!--     C.setArray2PyTree(a, "Zone-001/GridCoordinates/CoordinateX", T) -->
<!--     </div> -->
<!--     <em>Example of use: </em><a href="Examples/Converter/setArray2PyTree.py"> Conversion of an array to a pyTree.</a> <br> -->

    <p></p>
    <h3>File / arrays or File / pyTree conversion</h3>
    <p></p>

    <strong>C.convertFile2Arrays</strong>:
    read a file and return a list of arrays:
    <div class="code">
      A = C.convertFile2Arrays(fileName, format=None, options)
    </div>

    For format needing multiple files (for ex: plot3d), multiple files can
    be specified in file name string as: "file.gbin,file.qbin".<br>
    In file format where variables name are undefined, the following one is
    adopted: <b>x, y, z, ro, rou, rov, row, roE, cellN</b>.<br>
    If format is unspecified, the format is guessed from file extension.<br>
    Several options are available to specify the discretization
    of vector elements (as defined in xfig or svg): <br>

    <table border="2" align="center" cellpadding="3" cellspacing="1" style="font-size:90%">
    <tr>
    <td>
    <strong>Option name</strong>
    </td>
    <td>
    <strong>Meaning</strong>
    </td>
    <td>
    <strong>Default value</strong>
    </td></tr>
    <tr>
    <td>
    nptsCurve
    </td>
    <td>
    Number of discretization points for curved vector elements
    </td>
    <td>
    20
    </td></tr>
    <tr>
    <td>
    nptsLine
    </td>
    <td>
    Number of discretization points for line vector elements
    </td>
    <td>
    2
    </td></tr>
    <tr>
    <td>
    density
    </td>
    <td>
    Number of discretization points per unit length in the output curve
    </td>
    <td>
    No default value (nptsLine, nptsCurve are used by default)
    </td></tr>
    </table><br>

    <strong>C.convertArrays2File</strong>:
    write a list of arrays to a file:
    <div class="code">
      C.convertArrays2File(A, fileName, format=None, options)
    </div>
    The following additionnal options are available:

    <table border="2" align="center" cellpadding="4" cellspacing="1" style="font-size:90%">
    <tr>
    <td>
    <strong>Option name</strong>
    </td>
    <td>
    <strong>Meaning</strong>
    </td>
    <td>
    <strong>Possible values</strong>
    </td>
    <td>
    <strong>Default value</strong>
    </td></tr>
    <tr>
    <td>
    int
    </td>
    <td>
    size of integer
    </td>
    <td>
    4, 8
    </td>
    <td>
    4
    </td></tr>
    <tr>
    <td>
    real
    </td>
    <td>
    size of real
    </td>
    <td>
    4, 8
    </td>
    <td>
    8
    </td></tr>
    <tr>
    <td>
    endian
    </td>
    <td>
    endianess
    </td>
    <td>
    'little', 'big'
    </td>
    <td>
    'big'
    </td></tr>
    <tr>
    <td>
    colormap (pov)
    </td>
    <td>
    colormap style
    </td>
    <td>
    1, 2,...
    </td>
    <td>
    0
    </td></tr>
    <tr>
    <td>
    dataFormat
    </td>
    <td>
    'printf' compatible data format (%[width][.precision]specifier)
    </td>
    <td>
    '%f ', '%.9e ', '%16.9e' ...
    </td>
    <td>
    '%.9e '
    </td></tr>
    <tr>
    <td>
    zoneNames
    </td>
    <td>
    list of zone names (struct zones, then unstruct zones)
    </td>
    <td>
    ['Zone1','Zone2','ZoneTampon']
    </td>
    <td>
    []
    </td></tr>
    </table><br>

    <strong>C.convertFile2PyTree</strong>:
    read a file to a pyTree:
    <div class="code">
    A = C.convertFile2PyTree('in.cgns', 'bin_cgns')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convertFile2PyTree.py"> read a file in a tree.</a> <br><br>

    <strong>C.convertPyTree2File</strong>:
    write a Python tree to a file:
    <div class="code">
    C.convertPyTree2File(A, 'out.cgns', 'bin_cgns')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convertPyTree2File.py"> write a Python tree to a file.</a> <br>

   <p></p>
     <a balise id="Formats">Recognised formats are:</balise>
    <ul>
    <li> bin_tp: binary tecplot file (.plt). <br>
    <em>Example of use: </em><a href="Examples/Converter/conv.py"> binary tecplot file read/write.</a>
    <li> fmt_tp: formatted tecplot file (.dat, .tp). <br>
    <em>Example of use: </em><a href="Examples/Converter/conv2.py"> formatted/binary tecplot file conversion.</a>
    <li> bin_v3d: binary v3d file (.v3d). <br>
    <li> fmt_v3d: formatted v3d file (.fv3d). <br>
    <em>Example of use: </em><a href="Examples/Converter/conv3.py"> binary/formatted v3d file conversion.</a>
    <li> bin_plot3d: binary plot3d file (.gbin). <br>
    <li> fmt_plot3d: formatted plot3d file (.gfmt). <br>
    <em>Example of use: </em><a href="Examples/Converter/convPlot3d.py"> binary plot3d read/write.</a>
    <li> fmt_pov: formatted povray raytracer file (.pov). <br>
    <em>Example of use: </em><a href="Examples/Converter/convPov.py"> convert mesh and density field to povray file.</a>
    <li> bin_df3: binary density file for povray raytracer (.df3). <br>
    <em>Example of use: </em><a href="Examples/Converter/convDf3.py"> convert density field to povray density file.</a>
    <li> fmt_mesh: formatted mesh (INRIA-Gamma) file (.mesh). <br>
    <em>Example of use: </em><a href="Examples/Converter/convMesh.py"> convert mesh file to arrays.</a>
    <li> fmt_gmsh: formatted GMSH file (.msh). <br>
    <em>Example of use: </em><a href="Examples/Converter/convGmsh.py"> convert gmsh file to arrays.</a>
    <li> bin_gmsh: binary GMSH file (.msh). <br>
    <li> fmt_su2: formatted SU2 (Stanford) file (.su2). <br>
    <em>Example of use: </em><a href="Examples/Converter/convSu2.py"> convert mesh file to arrays.</a>
    <li> fmt_cedre: formatted CEDRE (Onera) file (.d). <br>
    <em>Example of use: </em><a href="Examples/Converter/convCedre.py"> convert from/to cedre file.</a>
    <li> bin_stl: binary STL file (.stl). <br>
    <em>Example of use: </em><a href="Examples/Converter/convSTL.py"> convert STL file to arrays.</a>
    <li> fmt_stl: formatted STL file (.fstl). <br>
    <em>Example of use: </em><a href="Examples/Converter/convFSTL.py"> convert STL file to arrays.</a>
    <li> fmt_obj: formatted wavefornt Obj file (.obj). <br>
    <em>Example of use: </em><a href="Examples/Converter/convObj.py"> convert Obj file to arrays.</a>
    <li> bin_3ds: binary 3D studio file (.3ds). <br>
    <em>Example of use: </em><a href="Examples/Converter/conv3DS.py"> convert 3DS file to arrays.</a>
    <li> bin_ply: stanford binary PLY file (.ply). <br>
    <em>Example of use: </em><a href="Examples/Converter/convPly.py"> convert PLY file to arrays.</a>
    <li> bin_pickle: binary Python pickle format (.ref). <br>
    <em>Example of use: </em><a href="Examples/Converter/convPickle.py"> pickle arrays to a file.</a>
    <li> bin_wav: binary wav 8-bits sound file (.wav). <br>
    <em>Example of use: </em><a href="Examples/Converter/convWav.py"> convert a time-pressure array to wav file.</a>
    <li> fmt_xfig: formatted xfig file (.fig). <br>
    <em>Example of use: </em><a href="Examples/Converter/convXfig.py"> convert arrays to fig file.</a>
    <li> fmt_svg: formatted svg file (.svg). <br>
    <em>Example of use: </em><a href="Examples/Converter/convSvg.py"> convert arrays from/to svg file.</a>
    <li> bin_png: binary png file (.png). <br>
    <em>Example of use: </em><a href="Examples/Converter/convPng.py"> convert arrays from png file.</a>
    <li> bin_cgns or bin_adf: binary ADF CGNS file for pyTrees only (.cgns, .adf). <br>
    <li> bin_hdf: binary HDF CGNS file for pyTrees only (.hdf, .hdf5). <br>
    </ul>

    <p></p>
    <h3>Conversion to elsA profile</h3>
    <p></p>
    Following functions are specific to the elsA CGNS profile. <br>

    <strong>C.elsAProfile.convert2elsAxdt</strong>:
    convert a pyTree a to a pyTree b usable with elsA. If pyTree contains periodic matching joins, elsA parameter 'axis_ang_2' is set to 1.:
    <div class="code">
      import Converter.elsAProfile<br>
      b = Converter.elsAProfile.convert2elsAxdt(a)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convert2elsAxdtPT.py"> convert a pyTree to a tree compatible with elsA.</a><br><br>

    <strong>C.elsAProfile.addReferenceState</strong>:
    add a reference state node in each base. You must specify conservative as
    a list of reference conservative values. You can optionaly specify
    temp, a reference temperature, turbmod, the turbulence model
    in 'komega', 'kkl', 'smith', 'spalart', 'keps', 'rsm', and reference 
    values for k and eps.
    Name of node and comments can also be specified:
    <div class="code">
    B = Converter.elsAProfile.addReferenceState(A, conservative=[1.,...],
    temp=None,
    turbmod='spalart', name='ReferenceState', comments=None, k=None, eps=None)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addReferenceStatePT.py"> add a reference state compatible with elsA.</a><br><br>

    <strong>C.elsAProfile.addGlobalConvergenceHistory</strong>:
    add a convergence node in each base. The type of norm used in
    residual computation can be specified (0: L0, 1: L2):
    <div class="code">
    B = Converter.elsAProfile.addGlobalConvergenceHistory(A, normValue=0)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addGlobalConvergenceHistoryPT.py"> add a convergence node compatible with elsA.</a><br><br>

    <strong>C.elsAProfile.addFlowSolution</strong>:
    add a FlowSolution node for each zone. name is a suffix that can be appened to the 'FlowSolution' name. loc must be 'Vertex' or 'CellCenter' or 'cellfict'. governingEquation is the name of the 'GoverningEquation' node. output
    can be optionaly a dictionary specifying the '.Solver#Output' node data.
    If addBCExtract is true, the boundary windows are also extracted. protocol
    is an optional string in 'iteration', 'end', 'after', specifying when extraction is performed:
    <div class="code">
    B = Converter.elsAProfile.addFlowSolution(A, name='', loc='CellCenter', variables=None,
                     governingEquations=None, writingMode=None,
                     writingFrame='relative', period=None, output=None,
                     addBCExtract=False, protocol="end")
    </div>
    <div class="code">
    B = Converter.elsAProfile.addFlowSolutionEoR(A, name='', loc='CellCenter', variables=None,
                     governingEquations=None, writingMode=None,
                     writingFrame='relative', period=None, output=None,
                     addBCExtract=False, protocol="end")
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addFlowSolutionPT.py"> add a flow solution extraction node.</a><br><br>

    <strong>C.elsAProfile.addOutputForces</strong>:
    add an output forces node to a BC or a family BC node. name is an optional
    string to complete output node name, var is a list of variables to extract,
    writingmode specifies the elsA writing mode. period specifies the number of
    iterations between two extractions. pinf is the value of infinite
    stagnation pressure. fluxcoeff is an optional value used to correct
    the extracted value. torquecoeff is an optional value used to
    correct the extracted value. xyz torque is the origin for torque.
    frame must be in ['relative','absolute']:
    <div class="code">
    B = Converter.elsAProfile.addOutputForces(A, name="", var=None,
    loc=4, writingmode=1, period=None, pinf=None, fluxcoef=None,
    torquecoef=None, xyztorque=None, frame=None,
    governingEquations="NSTurbulent", xtorque=None,
    ytorque=None, ztorque=None)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addOutputForcesPT.py"> add a forces output node.</a><br><br>

    <strong>C.elsAProfile.addOutputFriction</strong>:
    add an output friction node to a BC or a family BC node. name is an optional
    string to complete output node name, var is a list of variables to extract.
    loc specifies the location of extraction.
    writingmode specifies the elsA writing mode. period specifies the number of
    iterations between two extractions.
    fluxcoeff is an optional value used to correct the extracted value:
    <div class="code">
    B = Converter.elsAProfile.addOutputFriction(A, name="", var=None,
    loc=4, writingmode=1, period=None, fluxcoef=None,
    torquecoef=None, writingframe=None)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addOutputFrictionPT.py"> add a friction output node.</a><br><br>


    <p></p>
    <h3>Preconditionning (hook)</h3>
    <p></p>
    <strong>C.createHook</strong>:
    create a hook for each zone in a. The hook is used to store pre-computed data on a,
    and can be reused by a function if the zones defined in a are not modified.
    Parameter 'function' can be: <br>

    <table border="2" align="center" cellpadding="3" cellspacing="1" style="font-size:90%">
    <tr>
    <td>
    <strong>function name</strong>
    </td>
    <td>
    <strong>Type of storage</strong>
    </td>
    <td>
    <strong>Usage</strong>
    </td></tr>
    <tr>
    <td>
    'extractMesh'
    </td>
    <td>
    Bounding boxes of cells stored in an ADT.
    Valid for structured and TETRA zones.
    </td>
    <td>
    Post.extractMesh, Post.extractPoint functions
    </td></tr>
    <tr>
    <td>
    'adt'
    </td>
    <td>
    Bounding boxes of cells stored in an ADT.
    Valid for 3D structured and TETRA and 2D structured zones (nk=1 and z constant).
    </td>
    <td>
    Connector.setInterpData, Connector.setIBCData functions
    </td></tr>
    <tr>
    <td>
    'nodes'
    </td>
    <td>
    Mesh nodes stored in a k-d tree
    </td>
    <td>
      Converter.identifyNodes, Converter.nearestNodes
    </td></tr>
    <tr>
    <td>
    'faceCenters'
    </td>
    <td>
    Mesh face centers stored in a k-d tree
    </td>
    <td>
      Converter.identifyFaces, Converter.nearestFaces
    </td></tr>
    <tr>
    <td>
    'elementCenters'
    </td>
    <td>
    Element centers stored in a k-d tree
    </td>
    <td>
      Converter.identifyElements, Converter.nearestElements
    </td></tr>
    </table>

    Function usage:
    <div class="code">
    hook = C.createHook(a, function)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/createHook.py"> create a hook for extractMesh (array)</a>,
    <a href="Examples/Converter/createHookPT.py"> create a hook for extractMesh (pyTree)</a>.<br><br>

    <strong>C.createGlobalHook</strong>:
    create a global hook on a preconditioning tree.
    If extended=0, returns the hook in a list.
    If extended=1, returns the hook and an indirection numpy array of block number for each point stored in the preconditioning tree defined in the hook.<br>
    Parameter 'function' can be:<br>
    <table border="2" align="center" cellpadding="3" cellspacing="1" style="font-size:90%">
    <tr>
    <td>
    <strong>function name</strong>
    </td>
    <td>
    <strong>Type of storage</strong>
    </td>
    <td>
    <strong>Usage</strong>
    </td></tr>
    <tr>
    <td>
    'nodes'
    </td>
    <td>
    Mesh nodes stored in a global k-d tree
    </td>
    <td>
      Converter.identifySolutions
    </td></tr>
    <tr>
    <td>
    'faceCenters'
    </td>
    <td>
    Mesh face centers stored in a global k-d tree
    </td>
    <td>
      Converter.identifySolutions
    </td></tr>
    <tr>
    <td>
    'elementCenters'
    </td>
    <td>
    Element centers stored in a global k-d tree
    </td>
    <td>
      Converter.identifySolutions
    </td></tr>
    </table>

    <div class="code">
    hook = C.createGlobalHook(A, function='None')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/createGlobalHook.py"> create a global hook (array)</a>,
    <a href="Examples/Converter/createGlobalHookPT.py"> create a global hook (pyTree)</a>.<br><br>

    <strong>C.freeHook</strong>:
    free a hook created by createHook:
    <div class="code">
    C.freeHook(hook)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/freeHook.py"> free hook (array)</a>,
    <a href="Examples/Converter/createHookPT.py"> free hook (pyTree)</a>.<br><br>

    <p></p>
    <h3>Geometrical identification</h3>
    <p></p>
    <strong>C.identifyNodes</strong>:
    identify nodes of a with points stored in hook. Return the indices
    of hook corresponding to the nodes of a:
    <div class="code">
    C.identifyNodes(hook, a, tol=1.e-12)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/identifyNodes.py"> identify nodes in hook (array)</a>,
    <a href="Examples/Converter/identifyNodesPT.py"> identify nodes in hook (pyTree)</a>.<br><br>

    <strong>C.identifyFaces</strong>:
    identify face centers of a with points stored in hook. Return the indices
    of hook corresponding to the faces of a:
    <div class="code">
    C.identifyFaces(hook, a, tol=1.e-12)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/identifyFaces.py"> identify faces in hook (array)</a>,
    <a href="Examples/Converter/identifyFacesPT.py"> identify faces in hook (pyTree)</a>.<br><br>

    <strong>C.identifyElements</strong>:
    identify element centers of a with points stored in hook. Return the
    indices of hook corresponding to the elements of a:
    <div class="code">
    C.identifyElements(hook, a, tol=1.e-12)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/identifyElements.py"> identify elements in hook (array)</a>,
    <a href="Examples/Converter/identifyElementsPT.py"> identify elements in hook (pyTree)</a>.<br><br>

    <strong>C.identifySolutions</strong>:
    Copy the field defined on given donor zones to
    receptor zones where points are at a distance inferior to tol.

    This function doesn't perform interpolation but directly copy
    the field of the nearest donor points, if it is nearer than tol.
    Otherwise the field is set to 0.<br>

    The array interface returns the arrays corresponding to fields
    defined in solDnr. The arrays coordsRcv
    are the receptor coordinate arrays. Donor coordinates are
    stored in a kdtree hook:
    <div class="code">
    b = C.identifySolutions(coordsRcv, solDnr, hookDnr, vars=[], tol=1.e-12)
    </div>
    The pyTree interface requires a donor and a receptor pyTree.
    hookN can store the coordinates of donor nodes,
    and hookC can store the coordinates of donor cell centers.
    If hookN=None or hookC=None, then solution is not identified for nodes
    or centers respectively.
    The variables that must be identified can be specified by the list of
    string vars. If vars=[], then all the variables of tDnr are set to tRcv:
    <div class="code">
    t = C.identifySolutions(tRcv, tDnr, hookN=None, hookC=None, vars=[], tol=1.e-12)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/identifySolutions.py"> copy solution to a mesh (array)</a>,
    <a href="Examples/Converter/identifySolutionsPT.py"> copy solution to a mesh (pyTree)</a>.<br><br>

    <strong>C.nearestNodes</strong>:
    find nearest points stored in hook to nodes of a. Return the indices
    of hook nearest to the nodes of a and the corresponding distance:
    <div class="code">
    C.nearestNodes(hook, a)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/nearestNodes.py"> find nearest points to  nodes in hook (array)</a>,
    <a href="Examples/Converter/nearestNodesPT.py"> find nearest points to  nodes in hook (pyTree)</a>.<br><br>

    <strong>C.nearestFaces</strong>:
    find nearest points stored in hook to face centers of a. Return the indices
    of hook nearest to the faces of a and the corresponding distance:
    <div class="code">
    C.nearestFaces(hook, a)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/nearestFaces.py"> find nearest points to faces in hook (array)</a>,
    <a href="Examples/Converter/nearestFacesPT.py"> find nearest points to faces in hook (pyTree)</a>.<br><br>

    <strong>C.nearestElements</strong>:
    find nearest points stored in hook to element centers of a. Return the
    indices of hook nearest to the elements of a and the corresponding distance:
    <div class="code">
    C.nearestElements(hook, a)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/nearestElements.py"> find nearest points to  elements in hook (array)</a>,
    <a href="Examples/Converter/nearestElementsPT.py"> find nearest points to  elements in hook (pyTree)</a>.<br><br>


    <p></p>
    <h3>Distributed trees</h3>
    <p></p>
    Converter can also manage distributed trees, that is trees where
    zones are distributed over different processors.
    Three new concepts are introduced in addition of
    standard pyTrees: the skeleton tree, the loaded skeleton tree and
    the partial tree.<br>
    A skeleton tree (S) is a full pyTree where float numpy arrays with
    more than 100 elements are replaced by None. <br>
    A loaded skeleton tree (LS) is a skeleton tree with zones attributed
    to the current processor fully loaded. <br>
    A partial tree (P) is a pyTree with only zones attributed
    to the current processor fully loaded. It can be viewed as a "cleaned"
    loaded skeleton tree.<br>

    Access to distributed tree functions is provided by:
    <div class="code">
      import Converter.Mpi as Cmpi
    </div><br>

    <strong>Cmpi.convertFile2SkeletonTree</strong>:
    return a skeleton tree from a file (only ADF or HDF). If float data array size is lower than maxFloatSize then the array is loaded. If maxDepth is
    specified, load is limited to maxDepth levels:
    <div class="code">
    A = Cmpi.convertFile2SkeletonTree('in.cgns', maxFloatSize=5, maxDepth=-1)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convertFile2SkeletonTreePT.py"> return a skeleton tree from a file (pyTree).</a> <br><br>

    <strong>Cmpi.readZones</strong>:
    load zones of a skeleton tree referenced by proc number in a
    .Solver#Param/proc node (only ADF or HDF):
    <div class="code">
    B = Cmpi.readZones(A, 'in.cgns', proc=0)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/readZonesPT.py"> read zones to a skeleton tree (pyTree).</a> <br><br>

    <strong>Cmpi.convertPyTree2File</strong>:
    write a loaded skeleton tree or a partial tree to a file:
    <div class="code">
    Cmpi.convertPyTree2File(A, 'in.cgns', proc=0)
    </div>

    <strong>Cmpi.convert2PartialTree</strong>:
    convert a loaded skeleton tree to a partial tree
    If rank=-1, get rid of skeleton zones. If rank>=0, get rid of
    zones with a proc different of rank:
    <div class="code">
    B = Cmpi.convert2PartialTree(A, rank=-1)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convert2PartialTreePT.py"> convert a loaded skeleton tree to a partial tree (pyTree).</a> <br><br>

    <strong>Cmpi.createBBoxTree</strong>:
    from a partial tree or a loaded skeleton tree, create a full tree
    containing bbox of zones (identical on all processors). Argument method can be
    'AABB' (axis aligned bbox) or 'OBB' (oriented bbox):
    <div class="code">
    B = Cmpi.createBBoxTree(A, method='AABB')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/createBBoxTreePT.py"> create a bbox tree (pyTree).</a> <br><br>

    <strong>Cmpi.getProc</strong>:
    return the proc of a zone (can be a skeleton zone). If zone has not
    been affected, return -1:
    <div class="code">
    proc = Cmpi.getProc(z)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getProcPT.py"> get the proc of a zone (pyTree).</a> <br><br>

    <strong>Cmpi.setProc</strong>:
    set proc to a (can be skeleton):
    <div class="code">
    b = Cmpi.setProc(a) <em>.or.</em> B = Cmpi.setProc(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/setProcPT.py"> set the proc in a tree (pyTree).</a> <br><br>

    <strong>Cmpi.getProcDict</strong>:
    return the dictionary proc['zoneName'] from a skeleton, loaded skeleton or
    partial tree:
    <div class="code">
    procDict = Cmpi.getProcDict(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/getProcDictPT.py"> get the proc dictionary (pyTree).</a> <br><br>

    <strong>Cmpi.computeGraph</strong>:
    compute a graph. The graph is a dictionary
    such that graph[proc1][proc2] contains the names of zones
    of proc1 that are "connected" to at least one zone on proc2.<br>

    If type='bbox', a zone is connected to another if their bbox intersects.
    A must be a bbox tree.<br>
    If type='bbox2', a zone is connected to another if their bbox intersects
    and are not in the same base. A must be a bbox tree.<br>
    If type='bbox3', a zone is connected to another of another tree
    if their bbox intersects. A and t2 must be a bbox tree.<br>

    If type='match' (S/LS/P), a zone is connected to another if they have a
    match between them. A can be a skeleton, loaded skeleton or a partial tree.<br>

    If type='ID' (S/LS/P), a zone is connected to another if they have
    interpolation data between them. A can be a skeleton, a loaded skeleton
    or a partial tree.<br>

    If type='IBCD' (S/LS/P), a zone is connected to another if they have
    IBC data between them. A can be a skeleton, a loaded skeleton
    or a partial tree.<br>

    If type='ALLD' (S/LS/P), a zone is connected to another if they have
    Interpolation or IBC data between them. A can be a skeleton, a loaded
    skeleton or a partial tree.<br>

    If type='proc', a zone is attributed to another proc than the one
    it is loaded on. A can be a skeleton, a loaded skeleton tree or
    a partial tree.<br>
    <div class="code">
    graph = Cmpi.computeGraph(A, type='bbox', t2=None)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/computeGraphPT.py"> compute communication graph (pyTree).</a> <br><br>

    <strong>Cmpi.addXZones</strong>:
    add zones loaded on a different processor that are connected to local
    zones through the graph:
    <div class="code">
    B = Cmpi.addXZones(A, graph)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/addXZonesPT.py"> add zones (pyTree).</a> <br><br>

    <strong>Cmpi.rmXZones</strong>:
    remove zones created by addXZones:
    <div class="code">
    B = Cmpi.rmXZones(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/rmXZonesPT.py"> rm zones created by addXZones (pyTree).</a> <br><br>

    <strong>Cmpi.center2Node</strong>:
    center2Node for distributed trees:
    <div class="code">
    B = Cmpi.center2Node(A, 'centers:Density')
    </div>
    <em>Example of use: </em><a href="Examples/Converter/center2NodeDPT.py"> Pass a variable from centers to node (pyTree).</a> <br><br>

    <p></p>
    <h3>Client/server to exchange arrays/pyTrees</h3>
    <p></p>
    <strong>C.createSockets</strong>:
    create sockets for receiving arrays/pyTrees. If you are sending
    from a MPI run with nprocs, set nprocs accordingly:
    <div class="code">
    sockets = C.createSockets(nprocs=1, port=15555)
    </div>
    <br>

    <strong>C.listen</strong>:
    listen from created sockets. A is whatever has been sent:
    <div class="code">
    A = C.listen(sockets)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/listen.py"> listen for arrays.</a>,  
    <a href="Examples/Converter/listenPT.py"> listen for pyTrees.</a><br><br>
    
    <strong>C.send</strong>:
    send information to server:
    <div class="code">
    C.send(a, 'localhost', rank=0, port=15555)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/send.py"> send arrays.</a>,  
    <a href="Examples/Converter/sendPT.py"> send pyTrees.</a><br><br>

    <p></p>
    <h3>Converter arrays / 3D arrays conversion</h3>
    <p></p>
    In some applications, arrays must be seen as 3D arrays, that is (ni,nj,nk)
    numpy arrays instead of (nfld, ni*nj*nk) arrays. A 3D array is defined as
    [ ['x','y',...],[ ax, ay, ... ] ] where ax is a (ni,nj,nk) numpy array
    corresponding to variable x, and so on...<br>

    <strong>C.Array3D.convertArrays2Arrays3D</strong>:
    convert arrays to 3D arrays (ni,nj,nk):
    <div class="code">
    B = C.Array3D.convertArrays2Arrays3D(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convertArray2Array3D.py"> create 3D arrays from classical arrays.</a> <br><br>

    <strong>C.Array3D.convertArrays3D2Arrays</strong>:
    convert 3D arrays to arrays:
    <div class="code">
    B = C.Array3D.convertArrays3D2Arrays(A)
    </div>
    <em>Example of use: </em><a href="Examples/Converter/convertArray3D2Array.py"> create arrays from 3D arrays.</a> <br>

    <p></p>
    <h3>More general examples of use</h3>
    <p></p>

    <ul>
     <li> <a href="Examples/Converter/restart.py"> Save a binary tecplot file (output.plt) as multiple v3d files as used for computation restart.</a>
     <li> <a href="Examples/Converter/conv8.py"> Read a structured file and an unstructured file. Write a global file.</a>
     <li> <a href="Examples/Converter/shell.py"> How to transform a Python script in a shell?</a>
    </ul>

    <hr>
    <a href="Userguide.html">Return to main userguide</a>
  </body>
</html>
