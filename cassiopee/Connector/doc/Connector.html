<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Connector: Grid Connectivity module</title>
    <link href="Cassiopee.css" rel="stylesheet" type="text/css">
    <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-31301505-1', 'auto');ga('send', 'pageview');</script>
  </head>

  <body>
    <h1>Connector: Grid Connectivity</h1>
    <h2>Version: 2.5 (20/09/2017)</h2>
    <h2>Author: Onera</h2>
    <h2><a href="Latex/Connector.pdf" target="_self"><img src="pdf_logo.gif" alt="Download pdf version."></a></h2>
  <HR>

    <h3>Preamble</h3>

    Connector module is used to compute connectivity between meshes.
    It manipulates arrays (as defined in Converter documentation)
    or CGNS/Python trees (pyTrees) as data
    structures.<br><br>

    This module is part of Cassiopee, a free open-source
    pre- and post-processor for CFD simulations.<br><br>

    To use the Connector module with the array interface:
    <div class="code">
    import Connector as X
    </div>
    and with the pyTree interface:
    <div class="code">
    import Connector.PyTree as X
    </div>

    <p></p>
    <h3>Connectivity with arrays</h3>
    <p></p>
     <strong>X.connectMatch</strong>:
    detect and set all matching windows, even partially between two structured arrays a1 and a2.
    Returns the subrange of indices of abutting windows and an index transformation from a1 to a2.
    If the CFD problem is 2D, then dim must be set to 2.
    Parameter sameZone must be set to 1 if a1 and a2 define the same zone:
    <div class="code">
     res = X.connectMatch(a1, a2, sameZone=0, tol=1.e-6, dim=3)
    </div>
    <em>Example of use: </em><a href="Examples/Connector/connectMatch.py"> detect matching windows of a C-type mesh (array).</a><br><br>

    <strong>X.blankCells</strong>:
    blank the cells of a list of grids defined by coords (located at nodes).
    The X-Ray mask is defined by bodies, which is a list of arrays.
    Cellnaturefield defined in cellns is modified (0: blanked points, 1: otherwise).<br>
    Some parameters can be specified: blankingType, delta, masknot, tol. Their meanings are described in the table below:<br>

    <table border="2" align="center" cellpadding="3" cellspacing="1" style="font-size:90%">
    <tr>
    <td><strong>Parameter value </strong> </td>
    <td><strong>Meaning</strong></td>
    </tr>
    <tr><td> blankingType=0</td>
    <td>blank nodes inside bodies (node_in).</td></tr>
    <tr><td> blankingType=2</td>
    <td>blank cell centers inside bodies (center_in).</td></tr>
    <tr><td> blankingType=1</td>
    <td>blank cell centers intersecting with body (cell_intersect).</td></tr>
    <tr><td> blankingType=-2</td>
    <td>blank cell centers using an optimized cell intersection (cell_intersect_opt) and interpolation depth=2 (blanking region may be reduced where blanking point can be interpolated).</td></tr>
    <tr><td> blankingType=-1</td>
    <td>blank cell centers using an optimized cell intersection (cell_intersect_opt) and interpolation depth=1.</td></tr>
    <tr><td> delta=0.</td>
    <td> cells are blanked in the body </td></tr>
    <tr><td> delta greater than 0.</td>
    <td>the maximum distance to body, in which cells are blanked</td></tr>
    <tr><td> masknot=0</td>
    <td> Classical blanking applied</td></tr>
    <tr><td> masknot=1</td>
    <td> Inverted blanking applied: cells out of the body are blanked</td></tr>
    <tr><td> dim=3</td>
    <td> body described by a surface and blanks 3D cells.</td></tr>
    <tr><td> dim=2</td>
    <td> body blanks 2D or 1D zones.</td></tr>
    <tr><td> tol=1.e-8 (default)</td>
    <td> tolerance for the multiple definition of the body.</td></tr>
    </table>
    <br>
    Warning: in case of blankingType=0, location of cellns and coords must be identical.
    <div class="code">
    cellns = X.blankCells(coords, cellns, body, blankingType=2, delta=1.e-10,
    dim=3, masknot=0, tol=1.e-8)
    </div>
    <em> Example of use: </em><a href="Examples/Connector/blankCells.py"> blank cells (array)</a>.<br><br>

    <strong>X.blankCellsTetra</strong>:
    Blanks the input grids nodes or cells (depending on the <em>blankingType</em> value) that fall inside a volume body mask.<br>
    The blanking is achieved by setting the Cellnaturefield to <em>cellnval</em> (0 by default) in <em>cellns</em>.<br>
    The input grids are defined by coords located at nodes as a list of arrays. The body mask is defined by sets of tetrahedra in any orientation, as a list of arrays.<br><br>

    If the <em>blankingMode</em> is set to 1 (overwrite mode), Cellnaturefield is reset to 1 for any node/cell outside the body mask.
    Hence the value of 1 is forbidden for cellnval upon entry (it will be replaced by 0).<br><br>

    The parameters meanings and values are described in the table below:<br>


    <table border="2" align="center" cellpadding="3" cellspacing="1" style="font-size:90%">
    <tr>
    <td><strong>Parameter value </strong> </td>
    <td><strong>Meaning</strong></td>
    </tr>
    <tr><td> blankingType=0</td>
    <td>blanks the nodes falling inside the body masks (node_in).</td></tr>
    <tr><td> blankingType=2</td>
    <td>blanks the cells having their center falling inside the body masks (center_in).</td></tr>
    <tr><td> blankingType=1</td>
    <td>blanks the cells that intersect or fall inside the body masks (cell_intersect).</td></tr>
    <tr><td> tol=1.e-12 (default)</td>
    <td> tolerance for detecting intersections (NOT USED CURRENTLY).</td></tr>
    <tr><td> cellnval=0 (default)</td>
    <td> value used for flagging as blanked.</td></tr>
    <tr><td> blankingMode=0 (default)</td>
    <td> Appending mode: cellns is only modified for nodes/cells falling inside the body mask by setting the value in cellns to cellnval.</td></tr>
    <tr><td> blankingMode=1 </td>
    <td> Overwriting mode: cellns is modified for both nodes/cells falling inside (set to cellnval) and outside (set to 1) the body mask.</td></tr>
    </table>
    <br>
    Warning: in case of blankingType=0, location of cellns and coords must be identical.
    <div class="code">
    cellns = X.blankCellsTetra(coords, cellns, body, blankingType=2, tol=1.e-12)
    </div>
    <em> Example of use: </em><a href="Examples/Connector/blankCellsTetra.py"> blank cells with tetra rep of the masks (array)</a>.<br><br>

    <strong>X.blankCellsTri</strong>:
    Blanks the input grids nodes or cells (depending on the <em>blankingType</em> value) that fall inside a surfacic body mask.<br>
    The blanking is achieved by setting the Cellnaturefield to <em>cellnval</em> (0 by default) in <em>cellns</em>.<br>
    The input grids are defined by coords located at nodes as a list of arrays. The body mask is defined by triangular surface meshes in any orientation, as a list of arrays.<br><br>

    If the <em>blankingMode</em> is set to 1 (overwrite mode), Cellnaturefield is reset to 1 for any node/cell outside the body mask.
    Hence the value of 1 is forbidden for cellnval upon entry (it will be replaced by 0).<br><br>

    The parameters meanings and values are described in the table below:<br>

    <table border="2" align="center" cellpadding="3" cellspacing="1" style="font-size:90%">
    <tr>
    <td><strong>Parameter value </strong> </td>
    <td><strong>Meaning</strong></td>
    </tr>
    <tr><td> blankingType=0</td>
    <td>blanks the nodes falling inside the body masks (node_in).</td></tr>
    <tr><td> blankingType=2</td>
    <td>blanks the cells having their center falling inside the body masks (center_in).</td></tr>
    <tr><td> blankingType=1</td>
    <td>blanks the cells that intersect or fall inside the body masks (cell_intersect).</td></tr>
    <tr><td> tol=1.e-12 (default)</td>
    <td> tolerance for detecting intersections (NOT USED CURRENTLY).</td></tr>
    <tr><td> cellnval=0 (default)</td>
    <td> value used for flagging as blanked.</td></tr>
    <tr><td> blankingMode=0 (default)</td>
    <td> Appending mode: cellns is only modified for nodes/cells falling inside the body mask by setting the value in cellns to cellnval.</td></tr>
    <tr><td> blankingMode=1 </td>
    <td> Overwriting mode: cellns is modified for both nodes/cells falling inside (set to cellnval) and outside (set to 1) the body mask.</td></tr>
    </table>
    <br>
    Warning: in case of blankingType=0, location of cellns and coords must be identical.<br><br>
    <div class="code">
    cellns = X.blankCellsTri(coords, cellns, body, blankingType=2, tol=1.e-12, cellnval=0, blankingMode=0)
    </div>
    <em> Example of use: </em><a href="Examples/Connector/blankCellsTri.py"> blank cells with triangular surface masks (array)</a>.<br><br>

    <strong>X.setHoleInterpolatedPoints</strong>:
    compute the fringe of interpolated points around a set of blanked points in a mesh a.
    Parameter depth is the number of layers of interpolated points to be set.
    If depth > 0 the fringe of interpolated points is set outside the blanked zones,
    whereas if depth < 0, the depth layers of blanked points are marked as to be interpolated.
    If dir=0, uses a directional stencil of depth points, if dir=1, uses a full depth x depth x depth stencil:
    Blanked points are identified by the variable 'cellN'; 'cellN' is set to 2 for the fringe of interpolated points.
    If cellN is located at cell centers, set loc parameter to 'centers', else loc='nodes'.
    <div class="code">
    a = X.setHoleInterpolatedPoints(a, depth=2, dir=0, loc='centers', cellNName='cellN')
    </div>
     <em> Example of use: </em><a href="Examples/Connector/setHoleInterpolatedPts.py"> set the fringe of interpolated points near blanked points (array).</a> <br><br>

    <strong>X.optimizeOverlap*</strong>:
    Optimize the overlap between two zones defined by nodes1 and nodes2, centers1 and centers2 correspond to the mesh located at centers and the field 'cellN'.
    The field 'cellN' located at centers is set to 2 for interpolable points. <br>
    Priorities can be defined for zones: prio1=0 means that the priority of zone 1 is high.
    If two zones have the same priority, then the cell volume criterion is used to set the cellN to 2 for one of the overlapping cells, the other not being modified.<br>
    If the priorities are not specified, the cell volume criterion is applied also:
    <div class="code">
    cellns = X.optimizeOverlap(nodes1, centers1, nodes2, centers2, prio1=0, prio2=0)
    </div>
    <em> Example of use: </em><a href="Examples/Connector/optimizeOverlap.py"> optimize the overlap (array)</a>.<br><br>

    <strong>X.maximizeBlankedCells</strong>:
    change useless interpolated points status (2) to blanked points (0).
    If dir=0, uses a directional stencil of depth points, if dir=1,
    uses a full depth x depth x depth stencil:
    <div class="code">
    b = X.maximizeBlankedCells(a, depth=2, dir=1) <em>.or.</em> B = X.maximizeBlankedCells(A, depth=2)
    </div>
    <em>Example of use: </em><a href="Examples/Connector/maximizeBlankedCells.py"> maximize blanked cells (array)</a>.<br><br>

    <strong>X.setDoublyDefinedBC</strong>:
    when a border of zone z is defined by doubly defined BC in range=[i1,i2,j1,j2,k1,k2],
    one can determine whether a point is interpolated or defined by the physical BC. The array cellN defines the cell nature field at centers for zone z.
    If a cell is interpolable from a donor zone, then the cellN is set to 2 for this cell.
    The lists listOfInterpZones and listOfCelln are the list of arrays defining the interpolation domains, and corresponding cell nature fields. depth can be 1 or 2. If case of depth=2,
    if one point of the two layers is not interpolable, then celln is set to 1 for both points:
    <div class="code">
    t = X.setDoublyDefinedBC(z, cellN, listOfInterpZones, listOfCelln, range, depth=2)
    </div>
    <em>Example of use: </em> <a href="Examples/Connector/setDoublyDefinedBC.py"> set interpolated/BC points on doubly defined BCs (array)</a>.<br><br>

    <strong>X.blankIntersectingCells</strong>:
    blank intersecting cells of a 3D mesh. Only faces normal to k-planes for structured meshes and faces normal to triangular faces for prismatic meshes, and faces normal to 1234 and 5678 faces for hexahedral meshes are tested.
    The cellN is set to 0 for intersecting cells/elements. Input data are A the list of meshes, cellN the list of cellNatureField located at cell centers.
    Array version: the cellN must be an array located at centers, defined separately:
   <div class="code">
    cellN = X.blankIntersectingCells(A, cellN, tol=1.e-10)
    </div>
    <em>Example of use: </em><a href="Examples/Connector/blankIntersectingCells.py"> intersecting cells blanking (array)</a>.<br><br>

    <p></p>
    <h3>Multiblock connectivities with pyTrees</h3>
    <p></p>
 
    <strong>X.connectMatch</strong>:
    detect and set all matching windows, even partially, in a zone node, a list of zone nodes or a complete pyTree.
    Set automatically the Transform node corresponding to the transformation from matching block 1 to block 2.
    If the CFD problem is 2D, then dim must be set to 2:
    <div class="code">
     t = X.connectMatch(t, tol=1.e-6, dim=3)
    </div>
    <em>Example of use: </em><a href="Examples/Connector/connectMatchPT.py"> add 1-to-1 abutting grid connectivity in a pyTree (pyTree)</a>.<br><br>

    <strong>X.connectMatchPeriodic</strong>:
    detect and set all periodic matching windows, even partially, in a zone node, a list of zone nodes, a basis, or a complete pyTree.
    Periodicity can be defined by a rotation or by a translation or by a composition of rotation and translation.
    If the mesh is periodic in rotation and in translation separately (i.e. connecting with some blocks in rotation, and some other blocks in translation), the function must be applied twice.
    Set automatically the Transform node corresponding to the transformation from matching block 1 to block 2, and the 'GridConnectivityProperty/Periodic' for periodic matching BCs.
    If the CFD problem is 2D, then dim must be set to 2:
    <div class="code">
     t = X.connectMatchPeriodic(t, rotationCenter=[0.,0.,0.], rotationAngle=[0.,0.,0.], translation=[0.,0.,0.], tol=1.e-6, dim=3)
    </div>
    <em>Example of use: </em><a href="Examples/Connector/connectMatchPeriodicPT.py"> add periodic  1-to-1 abutting grid connectivity in a pyTree (pyTree)</a>.<br><br>

    <strong>X.connectNearMatch</strong>:
    detect and set all near-matching windows, even partially in a zone node, a list of zone nodes or a complete pyTree.
    A 'UserDefinedData' node is set, with the PointRangeDonor, the Transform and NMRatio nodes providing information for the opposite zone.
    Warning: connectMatch must be applied first if matching windows exist.
    Parameter ratio defines the ratio between near-matching windows and can be an integer (e.g. 2) or a list of 3 integers (e.g. [1,2,1]), specifying
    the nearmatching direction to test (less CPU-consuming).
    If the CFD problem is 2D, then dim must be set to 2:
    <div class="code">
     t = X.connectNearMatch(t, ratio=2, tol=1.e-6, dim=3)
    </div>
    <em>Example of use: </em><a href="Examples/Connector/connectNearMatchPT.py"> add  n-to-m abutting grid connectivity in a pyTree (pyTree)</a>.<br><br>

   <strong>X.setDegeneratedBC</strong>:
    detect all degenerate lines in 3D zones and define a BC as a 'BCDegenerateLine' BC type. For 2D zones, 'BCDegeneratePoint'
    type is defined.
    If the problem is 2D according to (i,j), then parameter 'dim' must be set to 2.
    Parameter 'tol' defines a distance below which a window is assumed degenerated.
    <div class="code">
    t = X.setDegeneratedBC(t,dim=3,tol=1.e-10)
    </div>
    <em> Example of use: </em><a href="Examples/Connector/setDegeneratedBCPT.py"> add degenerated line as BCs in a pyTree (pyTree) </a>.<br><br>

    <p></p>
    <h3>Overset connectivities with pyTrees</h3>
    <p></p>

    <strong>X.getIntersectingDomains</strong>:
    create a Python dictionary describing the intersecting zones. If t2 is not provided, then the computed dictionary states the self-intersecting zone names, otherwise, it
    computes the intersection between t and t2. Mode can be 'AABB', for Axis-Aligned Bounding Box method, 'OBB' for Oriented Bounding Box method, or 'hybrid', using a combination
    of AABB and OBB which gives the most accurate result. Depending on the selected mode, the user can provide the corresponding AABB and/or OBB PyTrees of t and/or t2, so that the
    algorithm will reuse those BB PyTrees instead of calculating them:
    <div class="code">interDict = X.getIntersectingDomains(t, t2=None, method='AABB', taabb=None, tobb=None, taabb2=None, tobb2=None)</div>
    <em> Example of use: </em><a href="Examples/Connector/getIntersectingDomainsPT.py"> create the Intersection Dictionary (pyTree).</a><br><br>

    <strong>X.getCEBBIntersectingDomains</strong>:
    detect the domains defined in the list of bases B whose CEBB
    intersect domains defined in base A.
    Return the list of zone names for each basis.
    If sameBase=1, the intersecting domains are also searched in base:
    <div class="code">
    domNames = X.getCEBBIntersectingDomains(A, B, sameBase)
    </div>
    <em>Example of use: </em><a href="Examples/Connector/getCEBBIntersectingDomainsPT.py"> detect CEBB intersection between bases (pyTree)</a>.<br><br>

    <strong>X.getCEBBTimeIntersectingDomains</strong>:
    in a Chimera pre-processing for bodies in relative motion,
    it can be useful to determine intersecting domains at any iteration. <br>
    niter defines the number of iterations on which CEBB intersections are detected, starting from iteration inititer. <br>
    dt defines the timestep. <br>
    func defines a python function defining the motion of base, funcs is the list of python functions describing motions for bases.<br>
    Warning: 1. motions here are only relative motions. If all bases are translated with the same translation motion, it must not be defined in func.<br>
             2. If no motion is defined on a basis, then the corresponding function must be []:
    <div class="code">
    domNames = X.getCEBBTimeIntersectingDomains(base, func, bases, funcs, inititer=0, niter=1, dt=1, sameBase)
    </div>
    <em>Example of use: </em><a href="Examples/Connector/getCEBBTimeIntersectingDomainsPT.py"> CEBB intersection between bases with motions (pyTree)</a>.<br><br>

    <strong>X.applyBCOverlaps</strong>:
    set the cellN to 2 for the fringe nodes or cells (depending on parameter 'loc'='nodes' or 'centers') near the overlap borders defined in the pyTree t.
    Parameter 'depth' defines the number of layers of interpolated points.
    <div class="code">
    t = X.applyBCOverlaps(t, depth=2, loc='centers')
    </div>
     <em> Example of use: </em><a href="Examples/Connector/applyBCOverlapsPT.py"> set cellN to 2 near overlap BCs in a pyTree (pyTree).</a> <br><br>

    <strong>X.setDoublyDefinedBC</strong>:
    when a border is defined by doubly defined BC, one can determine whether a point is interpolated or defined by the physical BC. The cellN is set to 2 if cells near the doubly defined BC are interpolable from a specified donor zone:
    <div class="code"> t = X.setDoublyDefinedBC(t, depth=2) </div>
    <em> Example of use: </em> <a href="Examples/Connector/setDoublyDefinedBCPT.py"> set interpolated/BC points on doubly defined BCs (pyTree).</a> <br><br>

    <strong>X.blankCells</strong>:
    blankCells function sets the cellN to 0 to blanked nodes or cell centers of both structured and unstructured grids.
    The location of the cellN field depends on the blankingType parameter: if 'node_in' is used, nodes are blanked, else centers are blanked.
    The mesh to be blanked is defined by a pyTree t, where each basis defines a Chimera component. The list of bodies blanking the grids is defined in bodies.
    Each element of the list bodies is a set of CGNS/Python zones defining a closed and watertight surface. <br>
    The blanking matrix BM is a numpy array of size nbases x nbodies. <br>
    BM(i,j)=1 means that ith basis is blanked by jth body.<br>
    BM(i,j)=0 means no blanking, and BM(i,j)=-1 means that inverted hole-cutting is performed.<br>
    blankingType can be 'cell_intersect', 'cell_intersect_opt', 'center_in' or 'node_in'. Parameter depth is only meaningfull for 'cell_intersect_opt'.<br>
    XRaydim1 and XRaydim2 are the dimensions of the X-Ray hole-cutting in the x and y directions in 3D.<br>
    If the variable 'cellN' does not exist in the input pyTree, it is initialized to 1, located at 'nodes' if 'node_in' is set, and at centers in other cases.<br>
    Warning: 'cell_intersect_opt' can be CPU time-consuming when delta>0.
    <div class="code">
    B = X.blankCells(t, bodies, BM, depth=2, blankingType='cell_intersect', delta=1.e-10, dim=3, tol=1.e-8, XRaydim1=1000, XRaydim2=1000)
    </div>
    <em> Example of use: </em><a href="Examples/Connector/blankCellsPT.py"> blank cells (pyTree).</a><br><br>

    <strong>X.blankCellsTetra</strong>:
    Blanks the input grids nodes or cells (depending on the <em>blankingType</em> value) that fall inside a volume body mask.<br>
    The blanking is achieved by setting the Cellnaturefield to <em>cellnval</em> (0 by default) in <em>cellns</em>.<br>
    The mesh to be blanked is defined by a pyTree t, where each basis defines a Chimera component. The list of bodies blanking the grids is defined in bodies.
    Each element of the list bodies is a set of CGNS/Python zones defining a tetrahedra mesh. <br>
    The blanking matrix BM is a numpy array of size nbases x nbodies. <br>
    BM(i,j)=1 means that ith basis is blanked by jth body.<br>
    BM(i,j)=0 means no blanking, and BM(i,j)=-1 means that inverted hole-cutting is performed.<br>
    blankingType can be 'cell_intersect', 'center_in' or 'node_in'.<br>
    If the variable 'cellN' does not exist in the input pyTree, it is initialized to 1, located at 'nodes' if 'node_in' is set, and at centers in other cases.<br>
    If the <em>overwrite</em> is set to 1 (overwrite mode), Cellnaturefield is reset to 1 for any node/cell outside the body mask.
    Hence the value of 1 is forbidden for cellnval upon entry (it will be replaced by 0).<br><br>
    <div class="code">
    B = X.blankCellsTetra(t, bodies, BM, blankingType='node_in', tol=1.e-12, cellnval=0, overwrite=0)
    </div>
    <em> Example of use: </em><a href="Examples/Connector/blankCellsTetraPT.py"> blank cells with tetrahedra meshes masks (pyTree).</a><br><br>

    <strong>X.blankCellsTri</strong>:
    Blanks the input grids nodes or cells (depending on the <em>blankingType</em> value) that fall inside a volume body mask.<br>
    The blanking is achieved by setting the Cellnaturefield to <em>cellnval</em> (0 by default) in <em>cellns</em>.<br>
    The mesh to be blanked is defined by a pyTree t, where each basis defines a Chimera component. The list of bodies blanking the grids is defined in bodies.
    Each element of the list bodies is a set of CGNS/Python zones defining a triangular watertight closed surface. <br>
    The blanking matrix BM is a numpy array of size nbases x nbodies. <br>
    BM(i,j)=1 means that ith basis is blanked by jth body.<br>
    BM(i,j)=0 means no blanking, and BM(i,j)=-1 means that inverted hole-cutting is performed.<br>
    blankingType can be 'cell_intersect', 'center_in' or 'node_in'.<br>
    If the variable 'cellN' does not exist in the input pyTree, it is initialized to 1, located at 'nodes' if 'node_in' is set, and at centers in other cases.<br>
    If the <em>overwrite</em> is set to 1 (overwrite mode), Cellnaturefield is reset to 1 for any node/cell outside the body mask.
    Hence the value of 1 is forbidden for cellnval upon entry (it will be replaced by 0).<br><br>
    <div class="code">
    B = X.blankCellsTri(t, bodies, BM, blankingType='node_in', tol=1.e-12, cellnval=0, overwrite=0)
    </div>
    <em> Example of use: </em><a href="Examples/Connector/blankCellsTriPT.py"> blank cells with triangular surface masks (pyTree).</a><br><br>

    <strong>X.setHoleInterpolatedPoints</strong>:
    compute the fringe of interpolated points around a set of blanked points in a pyTree t.
    Parameter depth is the number of layers of interpolated points that are built; if depth > 0 the fringe of interpolated points is outside the blanked zones, and if depth < 0,
    it is built towards the inside.
    Blanked points are identified by the variable 'cellN' located at mesh nodes or centers. 'cellN' is set to 2 for the fringe of interpolated points.
    <div class="code">
    t = X.setHoleInterpolatedPoints(t, depth=2, dir=0, loc='centers', cellNName='cellN')
    </div>
     <em> Example of use: </em><a href="Examples/Connector/setHoleInterpolatedPtsPT.py"> set the fringe of interpolated points near the blanked points (pyTree).</a> <br><br>

    <strong>X.optimizeOverlap</strong>:
    optimize the overlapping between all structured zones defined in a pyTree t.
    The 'cellN' variable located at cell centers is modified, such that cellN=2 for a cell interpolable from another zone. <br>
    Double wall projection technique is activated if 'double_wall'=1.
    The overlapping is optimized between zones from separated bases, and is based on a priority to the cell of smallest size.
    One can impose a priority to a base over another base, using the list priorities.
    For instance, priorities = ['baseName1',0, 'baseName2',1] means that zones from base of name 'baseName1' are preferred over
    zones from base of name 'baseName2':
    <div class="code">t = X.optimizeOverlap(t, double_wall=0, priorities=[])</div>
    <em> Example of use: </em><a href="Examples/Connector/optimizeOverlapPT.py"> optimize the overlapping (pyTree).</a><br><br>

    <strong>X.maximizeBlankedCells</strong>:
    change useless interpolated cells (cellN=2) status to blanked points (cellN=0). Parameter depth specifies the number of layers of interpolated cells to be kept:
    <div class="code">t = X.maximizeBlankedCells(t, depth=2) </div>
    <em>Example of use: </em><a href="Examples/Connector/maximizeBlankedCellsPT.py"> maximize blanked cells (pyTree).</a><br><br>

    <strong>X.cellN2OversetHoles</strong>:
    compute the OversetHoles node into a pyTree from the cellN field, located at nodes or centers. For structured zones, defines it as a list of ijk indices, located at nodes or centers.
    For unstructured zones, defines the OversetHoles node as a list of indices ind, defining the cell vertices that are of cellN=0 if the cellN is located at nodes, and defining the cell centers that are of cellN=0 if the cellN is located at centers.
    The OversetHoles nodes can be then dumped to files, defined by the indices of blanked nodes or cells:
    <div class="code"> t = X.cellN2OversetHoles(t)</div>
    <em>Example of use: </em><a href="Examples/Connector/cellN2OversetHolesPT.py"> create OversetHoles node</a>,
    </em><a href="Examples/Connector/oversetHoles2File.py"> dump OversetHoles node to a file (pyTree).</a><br><br>

    <strong>X.blankIntersectingCells</strong>:
    blank intersecting cells of a 3D mesh. Only faces normal to k-planes for structured meshes and faces normal to triangular faces for prismatic meshes,
    and faces normal to 1234 and 5678 faces for hexahedral meshes are tested. Set the cellN to 0 for intersecting cells/elements. Input data are A the list of meshes, cellN the list of cellNatureField located at cell centers:
    The cellN variable is defined as a FlowSolution#Center node. The cellN is set to 0 for intersecting and negative volume cells:
    <div class="code">
    a = X.blankIntersectingCells(a, tol=1.e-10, depth=2)
    </div>
    <em>Example of use: </em><a href="Examples/Connector/blankIntersectingCellsPT.py"> blanking of intersecting cells (pyTree)</a>.<br><br>

    <strong> X.setInterpData</strong>:
    compute and store in a pyTree the interpolation information (donor and receptor points, interpolation type, interpolation coefficients) given receptors defined by aR,
    donor zones given by aD. If storage='direct', then aR with interpolation data stored in receptor zones are returned, and if storage='inverse', then aD with interpolation data stored in donor zones are returned.
    Donor zones can be structured or unstructured TETRA. receptor zones can be structured or unstructured. <br>
    Interpolation order can be 2, 3 or 5 for structured donor zones, only order=2 for unstructured donor zones is performed.<br>
    Parameter loc can 'nodes' or 'centers', meaning that receptor points are zone nodes or centers. <br>
    penalty=1 means that a candidate donor cell located at a zone border is penalized against interior candidate cell.<br>
    nature=0 means that a candidate donor cell containing a blanked point(cellN=0) is not valid. If nature=1 all the nodes of the candidate donor cell must be cellN=1 to be valid.<br>
    double_wall=1 activates the double wall correction. If there are walls defined by families in aR or aD, the corresponding top trees topTreeRcv or/and topTreeDnr must be defined.<br>
    If sameName=1, interpolation from donor zones with the same name as
    receptor zones are avoided. <br>
    Interpolation data are stored as a ZoneSubRegion_t node, stored under the donor or receptor zone node depending of the storage:
    <div class="code"> a = X.setInterpData(aR, aD, double_wall=0, order=2, penalty=1, nature=0, loc='nodes', storage='direct', topTreeRcv=None, topTreeDnr=None,
 sameName=0) </div>
    <em> Example of use: </em> <a href="Examples/Connector/setInterpDataPT.py"> set interpolation data in the pyTree (pyTree).</a> <br><br>

    <strong> X.getOversetInfo</strong>:
    set information on Chimera connectivity, i.e. interpolated, extrapolated or orphan cells, donor aspect ratio and ratio between volume of donor and receptor cells.
    This function is compliant with the storage as defined for setInterpData function.
    If type='interpolated', variable 'interpolated' is created and is equal to 1 for interpolated and extrapolated points, 0 otherwise.
    If type='extrapolated', variable 'extrapolated' is created and its value is the sum of the absolute values of coefficients, 0 otherwise.
    If type='orphan', variable 'orphan' is created and is equal to 1 for orphan points,  0 otherwise.
    If type='cellRatio', variable 'cellRatio' is created and is equal to max(volD/volR,volR/volD) for interpolated and extrapolated points (volR and volD are volume of receptors and donors).
    If type='donorAspect', variable 'donorAspect' is created and is equal to the ratio between the maximum and minimum length of donors, and 0 for points that are not interpolated:
    <div class="code"> tR = X.getOversetInfo(tR,tD,type='interpolated') </div>
    <em> Example of use: </em> <a href="Examples/Connector/getOversetInfoPT.py"> get overset information (pyTree).</a><br><br>

    <p></p>
    <h3>Immersed Boundary (IBM) pre-processing with pyTrees</h3>
    <p></p>
    <strong>X.setIBCData*</strong>:
    compute and store IBM information (donor and receptor points, interpolation type, interpolation coefficients, coordinates of corrected, wall and interpolated points) given receptors defined by aR,
    donor zones given by aD. If storage='direct', then aR with interpolation data stored in receptor zones are returned, and if storage='inverse', then aD with interpolation data stored in donor zones are returned.
    Donor zones can be structured or unstructured TETRA. receptor zones can be structured or unstructured.<br>
    Interpolation order can be 2, 3 or 5 for structured donor zones, only order=2 for unstructured donor zones is performed.<br>
    Parameter loc can 'nodes' or 'centers', meaning that receptor points are zone nodes or centers. <br>
    penalty=1 means that a candidate donor cell located at a zone border is penalized against interior candidate cell.<br>
    nature=0 means that a candidate donor cell containing a blanked point(cellN=0) is not valid. If nature=1 all the nodes of the candidate donor cell must be cellN=1 to be valid.<br>
    Interpolation data are stored as a ZoneSubRegion_t node, stored under the donor or receptor zone node depending of the storage.
    aR must contain information about distances and normals to bodies, defined by 'TurbulentDistance','gradxTurbulentDistance','gradyTurbulentDistance' and 'gradzTurbulentDistance', located at nodes or cell centers.
    Corrected points are defined in aR as points with cellN=2, located at nodes or cell centers.
    Parameter he is a constant, meaning that the interpolated points are pushed away of a distance he from the IBC points if these are external to the bodies.
    Parameter hi is a constant. If hi=0., then the interpolated points are mirror points of IBC points. If hi>0., then these mirror points are then pushed away of hi from their initial position.
    hi and he can be defined as a field (located at nodes or centers) for any point.
    <div class="code"> a = X.setIBCData(aR, aD, order=2, penalty=0, nature=0, method='lagrangian', loc='nodes', storage='direct', he=0., hi=0., dim=3) </div>
    <em> Example of use: </em> <a href="Examples/Connector/setIBCDataPT.py"> set IBM data in the pyTree (pyTree).</a> <br><br>

    <strong>The following functions require Connector.ToolboxIBM.py module:</strong><br>

    Compute and store all the information required for IBM computations. Input data are:<br>
    <table border="2" align="center" cellpadding="3" cellspacing="1" style="font-size:90%">
    <tr>
    <td><strong>Parameter</strong> </td>
    <td><strong>Meaning</strong></td>
    </tr>
    <tr><td> t</td>
        <td> pyTree defining the computational domain as a structured mesh </td></tr>
    <tr><td> tb</td>
        <td> pyTree defining the obstacles. Each obstacle must be defined in a CGNS basis as a surface closed mesh, whose normals must be oriented towards
            the fluid region</td></tr>
    <tr><td> DEPTH</td>
        <td> number of layers of IBM corrected points (usually 2 meaning 2 ghost cells are required)</td></tr>
    <tr><td> loc='centers'(default)</td>
        <td> location of IBM points: at nodes if loc='nodes' or at cell centers if loc='centers'</td></tr>
    </table>
    <br>
    The problem dimension (2 or 3D) and the equation model (Euler, Navier-Stokes or RANS) are required in tb.
    Output data is:<br>
    - the pyTree t with a 'cellN' field located at nodes or centers, marking as computed/updated/blanked points for the solver (cellN=1/2/0).<br>
    - a donor pyTree tc storing all the information required to transfer then the solution at cellN=2 points:
    <div class="code"> t, tc = X.ToolboxIBM.prepareIBMData(t, tb, DEPTH=2, loc='centers') </div>
    <em>Example of use: </em> <a href="Examples/Connector/prepareIBMDataPT.py"> compute the IBM preprocessing (pyTree).</a><br><br>

    Extract the IBM particular points once the IBM data is computed and stored in a pyTree. These points are the IBM points that are marked
    as updated points for the IBM approach and the corresponding wall and interpolated (in fluid) points.<br>
    If information is stored in the donor pyTree tc, then a=tc, else a must define the receptor pyTree t.
    <div class="code"> ti = X.ToolboxIBM.extractIBMInfo(a)</div>
    <em>Example of use: </em> <a href="Examples/Connector/extractIBMInfoPT.py"> extract all the IBM points (pyTree).</a><br><br>

    Extract the solution at walls. If IBM data is stored in donor pyTree tc, then a must be tc, else a is the pyTree t.<br>
    If tb is None, then tw is the cloud of wall points. If tb is a triangular surface mesh, then the solution extracted at cloud points is interpolated
    on the vertices of the triangular mesh. a must contain the fields in the ZoneSubRegions of name prefixed by 'IBCD'. <br>
    <div class="code"> tw = X.ToolboxIBM.extractIBMWallFields(a,tb=None)</div>
    <em>Example of use: </em> <a href="Examples/Connector/extractIBMWallFieldsPT.py"> extract the solution on the wall (pyTree).</a><br><br>

    <p></p>
    <h3> Overset and Immersed Boundary transfers with pyTrees</h3>
    <p></p>
    The following function enables to update the solution at some points, marked as interpolated for overset and IBM approaches.

    <strong> X.setInterpTransfers</strong>:
    General transfers from a set of donor zones defined by topTreeD to receptor zones defined in aR.<br>
    Both Chimera and IBM transfers can be applied and are identified by the prefix name of the ZoneSubRegion node
    created when computing the overset or IBM interpolation data.<br>
    Parameter variables is the list of variable names that are transfered by Chimera interpolation.<br>
    Parameter variablesIBC defines the name of the 5 variables used for IBM transfers.<br>
    Parameter bcType can be 0 or 1 (see table below for details).<br>
    Parameter varType enables to define the meaning of variablesIBC, if their name is not standard (see table below for more details).<br>
    Parameter storage enables to define how the information is stored (see table below).<br>

   <table border="2" align="center" cellpadding="3" cellspacing="1" style="font-size:90%">
    <tr>
    <td><strong>Parameter </strong> </td>
    <td><strong>Meaning</strong></td>
    </tr>
    <tr><td> bcType = 0</td>
    <td>IBM transfers model slip conditions</td></tr>
     <tr><td> bcType = 1</td>
    <td>IBM transfers model no-slip conditions</td></tr>
    <tr><td> varType = 1</td>
    <td>Density,MomentumX,MomentumY,MomentumZ,EnergyStagnationDensity</td></tr>
    <tr><td> varType = 2</td>
    <td>Density,VelocityX,VelocityY,VelocityZ,Temperature</td></tr>
    <tr><td> varType = 3</td>
    <td>Density,VelocityX,VelocityY,VelocityZ,Pressure</td></tr>
    <tr><td> storage = 0</td>
    <td>interpolation data is stored in receptor zones aR</td></tr>
    <tr><td> storage = 1</td>
    <td>interpolation data is stored in donor zones topTreeD</td></tr>
    <tr><td> storage =-1</td>
    <td>interpolation data storage is unknown or can be stored in donor and receptor zones.</td></tr>
    <tr><td> extract = 1</td>
    <td> wall fields are stored in zone subregions (density and pressure, utau and yplus if wall law is applied).</td></tr>
    </table>
    <br><br>
    <div class="code"> aR = X.setInterpTransfers(aR, topTreeD, variables=None, variablesIBC=['Density', 'MomentumX', 'MomentumY', 'MomentumZ', 'EnergyStagnationDensity'], bcType=0, varType=1, storage='unknown') </div>
    <em> Example of use: </em> <a href="Examples/Connector/setInterpTransfersPT.py"> transfers the solution from donor zones to receptor zones (pyTree).</a> <br><br>

    <p></p>
    <h3> Overset connectivities for elsA solver with pyTrees</h3>
    <p></p>
    <em> The following functions are specific of elsA computations on overset structured grids. </em><br> <br>
    <strong>X.setInterpolations*</strong>:
    set the Chimera connectivity (EX points and cell centers to be interpolated, index for donor interpolation cell and interpolation coefficients). <br>
    Double wall projection technique is activated if 'double_wall=1'.
    Parameter 'sameBase=1' means that donor zones can be found in the same base as the current zone. <br>
    <!-- parallelDatas=[graph,rank,listOfInterpCells] is defined only in a coupling context. It contains the graph of communication, the rank of the current processor and the list of interpolated cells/faces indices.  <br> graph is a Python dictionary with the following structure : graph[proc1][proc2] gives the list of zones on processeur 1 which intersect with zones on processor 2. <br> -->
    loc='cell' or 'face' indicates the location of the interpolated points (cell center or face).
    Interpolations with location at 'face' correspond to interpolation for EX points according to elsA solver.<br>
    prefixFile is the prefix for the name of the connectivity files generated for elsA solver (solver='elsA') or Cassiopee solver (solver='Cassiopee'). If prefixFile is not defined by user, no files are generated. <br>
    nGhostCells is the number of ghost cells that are required by elsA solver when writing connectivity files.<br>
    If storage='direct', interpolation data are stored on the interpolated zone, if storage='inverse', interpolation data are stored in the donor zone as a ZoneSubRegion_t node:
    <div class="code"> t = X.setInterpolations(t, loc='cell', double_wall=0, storage='direct', prefixFile = '', sameBase=0, solver='elsA', nGhostCells=2)</div>
    <!-- <div class="code"> t = X.setInterpolations(t, loc='cell', double_wall=0, storage='direct', prefixFile = '', sameBase=0, parallelDatas=[])</div> -->
    <em> Example of use: </em> <a href="Examples/Connector/setInterpolationsPT.py"> set interpolations (pyTree).</a> <br><br>

    <strong>X.chimeraTransfer</strong>:
    compute Chimera transfers. This function is compliant with the storage as it is defined for setInterpolations function.
    Parameter storage='direct' means that interpolation data are stored in interpolated zones,
    and parameter storage='inverse' means that interpolation data are stored in donor zones.
    Parameter 'variables' specifies the variables for which the transfer is applied.<br>
    Only data stored at cell centers are transfered. <!-- Interpolation data (cells and coefficients) are also stored at centers.  -->
    <div class="code"> t = X.chimeraTransfer(t, storage='direct', variables=[])</div>
    <em> Example of use: </em> <a href="Examples/Connector/chimeraTransferPT.py"> compute Chimera transfers (pyTree).</a><br><br>

    <strong>X.chimeraInfo</strong>:
    set information on Chimera connectivity, i.e. interpolated, extrapolated or orphan cells, donor aspect ratio and ratio between
    volume of donor and receptor cells.
    This function is compliant with the storage as it is defined for setInterpolations function.
    If type='interpolated', variable 'centers:interpolated' is created and is equal to 1 for interpolated and extrapolated cells, 0 otherwise.
    If type='extrapolated', variable 'centers:extrapolated' is created and its value is the sum of the absolute values of coefficients, 0 otherwise.
    If type='orphan', variable 'centers:orphan' is created and is equal to 1 for orphan cells,  0 otherwise.
    If type='cellRatio', variable 'centers:cellRatio' is created and is equal to max(volD/volR,volR/volD) for interpolated and extrapolated cells (volR and volD are volume of receptor and donor cells).
    If type='donorAspect', variable 'centers:donorAspect' is created and is equal to the ratio between the maximum and minimum length of donor cells, and 0 for cells that are not interpolated:
    <div class="code"> t = X.chimeraInfo(t, type='interpolated')</div>
    <em> Example of use: </em> <a href="Examples/Connector/chimeraInfoPT.py"> set Chimera information (pyTree).</a><br><br>

    <hr>
    <a href="Userguide.html">Return to main userguide</a><p>
    <address><a href="mailto: christophe.benoit@onera.fr"></a></address>
  </body>
</html>
